     1                                  %define DEFAULT_ATTRIBUTES 0x07
     2                                  %define VIDEO_BASE_ADDRESS 0xB8000
     3                                  
     4                                  
     5                                  ORG 0x8000
     6                                  BITS 16
     7                                  
     8 00000000 87DB                    xchg bx,bx; pongo un magic breakpoint aquí
     9                                  
    10 00000002 EB34                    jmp Inicio
    11                                  
    12 00000004 07000000                atributos dd DEFAULT_ATTRIBUTES;
    13 00000008 00000000                fila dd 0
    14 0000000C 00000000                columna dd 0
    15 00000010 486F6C61206D756E64-     string_ptr db "Hola mundo"
    16 00000019 6F                 
    17                                  
    18                                  
    19                                  GDT:
    20 0000001A 00<rept>                    times 8 db 0 ; define 8 bytes sin nada para la entrada de la tabla
    21                                      
    22                                      SEL_CODIGO equ $-GDT ;esta cuenta daria 8, indicando el indice 1 de la tabla (TI=0 es decir GDT y RPL=00 es decir el privilegio maximo)
    23                                      
    24                                      ;DESCRIPTOR DE SEGMENTO DE CODIGO
    25 00000022 FF                          db 0xFF; bits 7:0 del limite
    26 00000023 FF                          db 0xFF; bis 15:8 del limite
    27 00000024 00                          db 0x00; bits 7:0 de la Base Address
    28 00000025 00                          db 0x00; bits 15:7 de la Base Address
    29 00000026 00                          db 0x00; bits 23:16 de la Base Address
    30 00000027 98                          db 10011000b;(Presente (x1) , Privilegio 0 (x2), Seg Datos o Codigo (S=1) (x1), De codigo (x1), Solo ejecucion,no conforme y no accedido (x3)
    31 00000028 CF                          db 11001111b; Granularidad 4k (x1), Default 32bits (x1), Fijos (x2), bits 19:16 limite (x4)
    32 00000029 00                          db 0x00; bits 31:24 de la Base Address
    33                                  
    34                                      SEL_DATOS equ $-GDT ;esta cuenta daria 16, indicando el indice 2 de la tabla (TI=0 es decir GDT y RPL=00 es decir el privilegio maximo)
    35                                      
    36                                      ;DESCRIPTOR DEL SEGMENTO DE DATOS
    37 0000002A FF                          db 0xFF; bits 7:0 del limite
    38 0000002B FF                          db 0xFF; bis 15:8 del limite
    39 0000002C 00                          db 0x00; bits 7:0 de la Base Address
    40 0000002D 00                          db 0x00; bits 15:7 de la Base Address
    41 0000002E 00                          db 0x00; bits 23:16 de la Base Address
    42 0000002F 92                          db 10010010b;(Presente (x1) , Privilegio 0 (x2), Seg Datos o Codigo (S=1) (x1), De datos (x1), De lectura/escritura, epansion hacia arriba, no accedido (x3)
    43 00000030 CF                          db 11001111b;Granularidad 4k (x1), Default 32bits (x1), Fijos (x2), bits 19:16 limite (x4)
    44 00000031 00                          db 0x00; bits 31:24 de la Base Address
    45                                      
    46                                      
    47 00000032 1800                    valor_gdtr: dw $-GDT; limite de la GDT, estos dos bytes van primero
    48 00000034 [1A000000]                          dd GDT; base de la gdt estos dos van despues
    49                                  
    50                                  Inicio:
    51 00000038 0F0116[3200]                lgdt [valor_gdtr]; cargo el registro con la GDT.
    52 0000003D FA                          cli; apago las interrupciones para que no entren durante el pasaje a modo protegido
    53 0000003E 0F20C0                      mov eax,cr0; cargo eax con cr0
    54 00000041 0C01                        or  al,1; pongo en 1 el bit de modo protegido
    55 00000043 0F22C0                      mov cr0,eax; lo bajo ya seteado a cr0
    56 00000046 EA[4B00]0800                jmp SEL_CODIGO:Modo_Prot; Esta instruccion se ejecuta en 16 bits!.
    57                                      
    58                                  Modo_Prot:
    59                                      BITS 32; Paso a 32 bits.
    60 0000004B 66B81000                    mov ax,SEL_DATOS;
    61                                    
    62                                      ;Cargo DS, SS y ES con el selector de datos, todos estos son segmentos de datos con permiso de lectura y escritura solapados en memoria!
    63 0000004F 8ED8                        mov ds,ax;
    64 00000051 8ED0                        mov ss,ax;
    65 00000053 8EC0                        mov es,ax;
    66                                      
    67 00000055 B8[FD010000]                mov eax,base_pila;
    68 0000005A 89C5                        mov ebp,eax; apunto tanto esp 
    69 0000005C 89C4                        mov esp,eax; como ebp a la base de la pila
    70                                  
    71 0000005E FF35[04000000]              push dword[atributos]
    72 00000064 FF35[08000000]              push dword[fila]
    73 0000006A FF35[0C000000]              push dword[columna]
    74 00000070 68[10000000]                push string_ptr 
    75                                  
    76 00000075 E805000000                  call print
    77                                  
    78 0000007A 58                          pop eax
    79 0000007B 58                          pop eax
    80 0000007C 58                          pop eax
    81 0000007D 58                          pop eax
    82                                  
    83 0000007E F4                          hlt
    84                                  
    85                                  ;void print(char *string_ptr, char columna, char fila, char color)
    86                                  ;Recibe:
    87                                  ; EIP de regreso: EBP+4
    88                                  ; sting_ptr: EBP+8
    89                                  ; columna: EBP+12
    90                                  ; fila: EBP+16
    91                                  ; color: EBP+20
    92                                  print:
    93 0000007F 55                          push ebp; guardo el base pointer original.
    94 00000080 89E5                        mov ebp, esp; cargo el stack pointer en el base pointer.
    95                                      
    96                                      ;La pantalla es de 80x25, debo hacer fila*80+columna para obtener la posición.
    97 00000082 B8A0000000                  mov eax, 160; cargo en eax la la cantidad de caracteres por fila*2 ya que cada caracter ocupa 2 bytes
    98 00000087 8B5D10                      mov ebx, [EBP+16]; cargo en ebx (EBP+16) en la cual quiero escribir y se lo guarda en edx:eax. (aquí estaría en la columna cero).
    99 0000008A F7E3                        mul ebx;
   100 0000008C 03450C                      add eax,[EBP+12]; le sumo la columna.
   101 0000008F 03450C                      add eax,[EBP+12]; le sumo la columna una segunda vez ya que cada caracter ocupa 2 bytes!!
   102 00000092 0500800B00                  add eax, VIDEO_BASE_ADDRESS; le sumo la base de video. Con lo que me queda la dirección de memoria
   103 00000097 89C7                        mov edi, eax ;cargo en el di la direccion inicial de memoria sobre la que debo escribir!. edi tendra la direccion donde debo empezar a escribir
   104 00000099 8B7508                      mov esi, [EBP+8];cargo en el si la direccion de donde comenzaré a sacar los caracteres. esi tendra la direccion donde tengo el primer caracter del texto
   105                                      
   106                                  ciclo_print:
   107 0000009C 8A06                        mov al,byte[esi]
   108 0000009E 8807                        mov byte[edi],al;copio el primer caracter del texto en la primera posicion de memoria
   109 000000A0 8A4514                      mov al,byte[EBP+20]
   110 000000A3 884701                      mov byte[edi+1],al;copio el color correspondiente en la segunda
   111 000000A6 83C702                      add edi,2 ;incremento la posicion del destino en 2
   112 000000A9 83C601                      add esi,1; incremento la posicion de la fuente en 1
   113 000000AC 803E00                      cmp byte[esi],0
   114 000000AF 75EB                        jne ciclo_print
   115                                  
   116                                  fin_print:
   117 000000B1 5D                          pop ebp; recupero el valor de ebp original
   118 000000B2 C3                          ret
   119                                      
   120                                       
   121 000000B3 00<rept>                times 509-($-$$) db 0;
   122                                  
   123 000001FD 00                      base_pila: db 0; defino la base de la pila casi al final del bootloader, en las direcciones más bajas
   124                                  
   125 000001FE 55                      db 0x55
   126 000001FF AA                      db 0xAA
   127                                  
   128                                  
   129                                      

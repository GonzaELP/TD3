     1                                  ;################################################################################
     2                                  ;#	Título: Codigo principal de la aplicacion de 32 bits						#
     3                                  ;#																				#
     4                                  ;#	Versión:		1.0							Fecha: 	27/04/2015				#
     5                                  ;#	Autor: 			D. Garcia					Tab: 	4						#
     6                                  ;#	Compilación:	Usar Makefile												#
     7                                  ;#	Uso: 			-															#
     8                                  ;#	------------------------------------------------------------------------	#
     9                                  ;#	Descripción:																#
    10                                  ;#	------------------------------------------------------------------------	#
    11                                  ;#	Revisiones:																	#
    12                                  ;#		1.0 | 27/04/2015 | D.GARCIA | Inicial									#
    13                                  ;#	------------------------------------------------------------------------	#
    14                                  ;#	TODO:																		#
    15                                  ;#		-																		#
    16                                  ;################################################################################
    17                                  
    18                                  ;--------------------------------------------------------------------------------
    19                                  ; Macros
    20                                  ;--------------------------------------------------------------------------------
    21                                  %define DEFAULT_ATTRIBUTES 0x07
    22                                  %define VIDEO_BASE_ADDRESS 0xB8000
    23                                  
    24                                  
    25                                  ;defines para el teclado
    26                                  %define SC_MAKE_E 0x12
    27                                  %define SC_MAKE_U 0x16
    28                                  %define SC_MAKE_D 0x20
    29                                  %define SC_MAKE_G 0x22
    30                                  %define SC_MAKE_P 0x19
    31                                  %define SC_MAKE_ESC 0x01
    32                                  
    33                                  %define SC_BREAK_E (SC_MAKE_E+0x80)
    34                                  %define SC_BREAK_U (SC_MAKE_U+0x80)
    35                                  %define SC_BREAK_D (SC_MAKE_D+0x80)
    36                                  %define SC_BREAK_G (SC_MAKE_G+0x80)
    37                                  %define SC_BREAK_P (SC_MAKE_P+0x80)
    38                                  %define SC_BREAK_ESC (SC_MAKE_ESC+0x80)
    39                                  
    40                                  %define DATA_PORT_PS2 0x60
    41                                  
    42                                  
    43                                  ;Defines multitasking.
    44                                  %define SC_MAKE_A 0x1E 
    45                                  %define SC_MAKE_B 0x30
    46                                  %define SC_MAKE_C 0x2E
    47                                  
    48                                  %define SC_BREAK_A (SC_MAKE_A+0x80)
    49                                  %define SC_BREAK_B (SC_MAKE_B+0x80)
    50                                  %define SC_BREAK_C (SC_MAKE_C+0x80)
    51                                  
    52                                  %define COUNT_T1_X 68
    53                                  %define COUNT_T1_Y 0x00
    54                                  
    55                                  %define COUNT_T2_X 68
    56                                  %define COUNT_T2_Y 0x01
    57                                  
    58                                  %define COUNT_T3_X 68
    59                                  %define COUNT_T3_Y 0x02
    60                                  
    61                                  ;SYSTEM CALLS
    62                                  %define SYS_PRINT 1
    63                                  %define SYS_CLRSCR 2
    64                                  %define SYS_GET_SCANCODE 3
    65                                  %define SYS_SET_SCANCODE 4
    66                                  %define SYS_ITOA 5
    67                                  %define SYS_HLT 6
    68                                  
    69                                  ;--------------------------------------------------------------------------------
    70                                  ; Simbolos externos
    71                                  ;--------------------------------------------------------------------------------
    72                                  GLOBAL		start32
    73                                  GLOBAL          print
    74                                  GLOBAL          clrscr
    75                                  GLOBAL          vect_handlers
    76                                  GLOBAL          sys_call          
    77                                  
    78                                  GLOBAL          kernel_idle
    79                                  
    80                                  EXTERN          SEL_CODIGO
    81                                  EXTERN          SEL_CODIGO_NP3
    82                                  EXTERN          SEL_DATOS
    83                                  EXTERN          SEL_DATOS_NP3
    84                                  
    85                                  EXTERN          tss_tt
    86                                  
    87                                  EXTERN          IDT32
    88                                  EXTERN          PAGE_DIR_SO
    89                                  EXTERN          PAGE_TABLES1_40_SO
    90                                  
    91                                  EXTERN          PAGE_DIR_TASK1
    92                                  EXTERN          PAGE_DIR_TASK2
    93                                  EXTERN          PAGE_DIR_TASK3
    94                                  
    95                                  EXTERN          __task1_stack_end 
    96                                  EXTERN          __task2_stack_end 
    97                                  EXTERN          __task3_stack_end 
    98                                  
    99                                  EXTERN          __task1_stack_NP3_end
   100                                  EXTERN          __task2_stack_NP3_end
   101                                  
   102                                  EXTERN          task1_context
   103                                  EXTERN          task2_context
   104                                  EXTERN          task3_context
   105                                  
   106                                  EXTERN          task1_SIMD
   107                                  EXTERN          task2_SIMD
   108                                  EXTERN          task3_SIMD
   109                                  
   110                                  ;********************************************************************************
   111                                  ; Datos
   112                                  ;********************************************************************************
   113                                  SECTION 	.data      
   114                                  
   115                                  vect_handlers:
   116                                  ;Handlers de excepciones
   117 00000000 [10010000]                  dd handler_excep0
   118 00000004 [33010000]                  dd handler_excep1
   119 00000008 [34010000]                  dd handler_excep2
   120 0000000C [35010000]                  dd handler_excep3
   121 00000010 [36010000]                  dd handler_excep4
   122 00000014 [37010000]                  dd handler_excep5
   123 00000018 [38010000]                  dd handler_excep6
   124 0000001C [5B010000]                  dd handler_excep7
   125 00000020 [AC010000]                  dd handler_excep8
   126 00000024 [D0010000]                  dd handler_excep9
   127 00000028 [D1010000]                  dd handler_excep10
   128 0000002C [D3010000]                  dd handler_excep11
   129 00000030 [D5010000]                  dd handler_excep12
   130 00000034 [D7010000]                  dd handler_excep13
   131 00000038 [FB010000]                  dd handler_excep14
   132 0000003C 00000000                    dd 0x0 ;Se saltea la 15, es reservada
   133 00000040 [3C040000]                  dd handler_excep16
   134 00000044 [3D040000]                  dd handler_excep17
   135 00000048 [3F040000]                  dd handler_excep18
   136 0000004C [40040000]                  dd handler_excep19
   137 00000050 [41040000]                  dd handler_excep20
   138 00000054 00000000<rept>              times 9 dd 0x0;Se saltea 21-29, son reservadas
   139 00000078 [42040000]                  dd handler_excep30
   140 0000007C 00000000                    dd 0x0;Se saltea la 31, es reservada
   141                                  
   142                                  ;Handlers de interrupciones
   143 00000080 [44040000]                  dd handler_interr0
   144 00000084 [A5060000]                  dd handler_interr1
   145 00000088 [B3060000]                  dd handler_interr2
   146 0000008C [B4060000]                  dd handler_interr3
   147 00000090 [B5060000]                  dd handler_interr4
   148 00000094 [E0060000]                  dd handler_interr5
   149 00000098 [E1060000]                  dd handler_interr6
   150 0000009C [E2060000]                  dd handler_interr7
   151 000000A0 [E3060000]                  dd handler_interr8
   152 000000A4 [E4060000]                  dd handler_interr9
   153 000000A8 [E5060000]                  dd handler_interr10
   154 000000AC [E6060000]                  dd handler_interr11
   155 000000B0 [E7060000]                  dd handler_interr12
   156 000000B4 [E8060000]                  dd handler_interr13
   157 000000B8 [E9060000]                  dd handler_interr14
   158 000000BC [EA060000]                  dd handler_interr15
   159                                  
   160                                      
   161                                  
   162 000000C0 00000000                entero_itoa dd 0
   163 000000C4 00<rept>                buffer_itoa times 11 db 0x00;lo maximo que puede tener un entero de 32 bits es 10 cifras, y 1 mas para el fin de cadena
   164                                  
   165 000000CF 00                      scan_code_actual db 0x0
   166                                  
   167 000000D0 00000000                sys_ticks dd 0x00
   168                                  
   169 000000D4 0000                    buffer_COM1 db 0x00,0x00 ;defino un buffer de un caracter!
   170                                  
   171 000000D6 07000000                atributos dd DEFAULT_ATTRIBUTES;
   172 000000DA 00000000                fila dd 0
   173 000000DE 00000000                columna dd 0
   174 000000E2 00                      string_ptr db 0x00
   175 000000E3 00                      db 0x0; fin de cadena
   176                                  
   177                                  ;Ubicacion en pantalla de los numeros
   178 000000E4 18000000                fila_cuenta dd 24
   179 000000E8 46000000                columna_cuenta dd 70
   180                                  
   181                                  msg_inicio:
   182 000000EC 496E6772657365206C-             db "Ingrese la opcion que desee: #DE=E, #UD=U, #DF=D, #GP=G, #PF=P",0
   183 000000F5 61206F7063696F6E20-
   184 000000FE 717565206465736565-
   185 00000107 3A202344453D452C20-
   186 00000110 2355443D552C202344-
   187 00000119 463D442C202347503D-
   188 00000122 472C202350463D5000 
   189                                  
   190 0000012B 5465636C6120455343-     msg_ej6 db "Tecla ESC presionada",0
   191 00000134 2070726573696F6E61-
   192 0000013D 646100             
   193                                  
   194 00000140 457863657063696F6E-     msg_excep0 db "Excepcion 0, division por cero",0 ;los ceros al final son para hacer el fin de linea!!
   195 00000149 20302C206469766973-
   196 00000152 696F6E20706F722063-
   197 0000015B 65726F00           
   198                                  
   199 0000015F 457863657063696F6E-     msg_excep6 db "Excepcion 6, codigo de operacion invalido",0 
   200 00000168 20362C20636F646967-
   201 00000171 6F206465206F706572-
   202 0000017A 6163696F6E20696E76-
   203 00000183 616C69646F00       
   204                                  
   205 00000189 457863657063696F6E-     msg_excep8 db "Excepcion 8, Doble falta ABORTAR",0
   206 00000192 20382C20446F626C65-
   207 0000019B 2066616C7461204142-
   208 000001A4 4F5254415200       
   209                                  
   210 000001AA 457863657063696F6E-     msg_excep13 db "Excepcion 13, fallo general de proteccion",0
   211 000001B3 2031332C2066616C6C-
   212 000001BC 6F2067656E6572616C-
   213 000001C5 2064652070726F7465-
   214 000001CE 6363696F6E00       
   215                                  
   216 000001D4 457863657063696F6E-     msg_excep14 db "Excepcion 14, fallo de pagina",0
   217 000001DD 2031342C2066616C6C-
   218 000001E6 6F2064652070616769-
   219 000001EF 6E6100             
   220                                  
   221                                  
   222                                  
   223                                  
   224                                  task_init:
   225 000001F2 00                          db 0x00
   226 000001F3 00                          db 0x00
   227 000001F4 00                          db 0x00
   228                                      
   229                                  task_pds:
   230 000001F5 [00000000]                  dd PAGE_DIR_TASK1
   231 000001F9 [00000000]                  dd PAGE_DIR_TASK2
   232 000001FD [00000000]                  dd PAGE_DIR_TASK3
   233                                  
   234                                  task_stacks_kernel:
   235 00000201 [00000000]                  dd __task1_stack_end
   236 00000205 [00000000]                  dd __task2_stack_end
   237 00000209 [00000000]                  dd __task3_stack_end
   238                                      
   239                                  task_stacks_NP3:
   240 0000020D [00000000]                  dd __task1_stack_NP3_end
   241 00000211 [00000000]                  dd __task2_stack_NP3_end
   242 00000215 [00000000]                  dd __task3_stack_end
   243                                      
   244                                  task_list:
   245 00000219 [00000000]                  dd task1
   246 0000021D [00000000]                  dd task2
   247 00000221 [00000000]                  dd task3
   248                                      
   249                                  task_contexts:
   250 00000225 [00000000]                  dd task1_context
   251 00000229 [00000000]                  dd task2_context
   252 0000022D [00000000]                  dd task3_context
   253                                      
   254                                  task_SIMD:
   255 00000231 [00000000]                  dd task1_SIMD
   256 00000235 [00000000]                  dd task2_SIMD
   257 00000239 [00000000]                  dd task3_SIMD
   258                                      
   259                                  task_priv:
   260 0000023D 03000000                    dd 0x03; Privilego tarea 1
   261 00000241 03000000                    dd 0x03; Privilego tarea 2
   262 00000245 00000000                    dd 0x00; Privilego tarea 3
   263                                  
   264                                  
   265                                  
   266                                  
   267                                  USE32
   268                                  ;********************************************************************************
   269                                  ; Codigo principal
   270                                  ;********************************************************************************
   271                                  SECTION  	.main 			progbits
   272                                  
   273                                  kernel_idle:
   274 00000000 F4                          hlt
   275 00000001 EBFD                        jmp kernel_idle
   276                                  
   277                                  ;;CODIGO AGREGADO POR GONZALO
   278                                  	
   279                                  ;********************************************************************************
   280                                  ;CODIGO DE LAS TAREAS
   281                                  ;********************************************************************************	
   282                                  SECTION .task1_code progbits
   283                                  task1:
   284 00000000 0F6E0D[7B000000]            movd mm1,[.task1_count]
   285 00000007 803D[7A000000]00            cmp byte[.task1_init],0x00 ; no se inició todavía
   286 0000000E 751B                        jne .normal_t1
   287                                      
   288 00000010 B801000000                  mov eax,SYS_PRINT; System call de IMPRESION en pantalla
   289 00000015 BB07000000                  mov ebx, DEFAULT_ATTRIBUTES ;Atributos de los caracteres
   290 0000001A B900000000                  mov ecx, COUNT_T1_Y ; Fila
   291 0000001F BA00000000                  mov edx, 0; Columna
   292 00000024 BE[8A000000]                mov esi, .msg_task1; Mensaje a imprimir
   293 00000029 CD80                        int 0x80; Llamo a la interrupcion
   294                                      
   295                                      .normal_t1:
   296 0000002B B803000000                  mov eax, SYS_GET_SCANCODE
   297 00000030 CD80                        int 0x80
   298 00000032 3D9E000000                  cmp eax,SC_BREAK_A
   299 00000037 753F                        jne .fin
   300                                      
   301                                      
   302 00000039 FF05[7B000000]              inc dword[.task1_count] ; incremento la variable que cuenta las pulsadas
   303                                      
   304 0000003F B804000000                  mov eax, SYS_SET_SCANCODE
   305 00000044 BB00000000                  mov ebx, 0x00; limpio el scan_code_actual, lo pongo en 0x00
   306 00000049 CD80                        int 0x80
   307                                  
   308 0000004B B805000000                  mov eax, SYS_ITOA
   309 00000050 BB[7F000000]                mov ebx, .buffer_itoa_t1
   310 00000055 8B0D[7B000000]              mov ecx, [.task1_count]
   311 0000005B CD80                        int  0x80
   312                                          
   313 0000005D B801000000                  mov eax,SYS_PRINT
   314 00000062 BB07000000                  mov ebx, DEFAULT_ATTRIBUTES
   315 00000067 B900000000                  mov ecx, COUNT_T1_Y
   316 0000006C BA44000000                  mov edx, COUNT_T1_X
   317 00000071 BE[7F000000]                mov esi, .buffer_itoa_t1
   318 00000076 CD80                        int 0x80
   319                                  
   320                                      .fin:
   321                                      ;mov eax,SYS_HLT
   322                                      ;int 0x80
   323 00000078 EB86                    jmp task1
   324                                  
   325 0000007A 00                      .task1_init db 0x00
   326 0000007B 00000000                .task1_count dd 0x00
   327 0000007F 00<rept>                .buffer_itoa_t1 times 11 db 0x00
   328 0000008A 546172656120312065-     .msg_task1 db "Tarea 1 ejecutandose, Cantidad de veces que se presiono la letra A:",0
   329 00000093 6A65637574616E646F-
   330 0000009C 73652C2043616E7469-
   331 000000A5 646164206465207665-
   332 000000AE 636573207175652073-
   333 000000B7 652070726573696F6E-
   334 000000C0 6F206C61206C657472-
   335 000000C9 6120413A00         
   336                                  
   337                                  SECTION .task2_code progbits
   338                                  task2:
   339 00000000 0F6E0D[7B000000]            movd mm1,[.task2_count]
   340 00000007 803D[7A000000]00            cmp byte[.task2_init],0x00 ; no se inició todavía
   341 0000000E 751B                        jne .normal_t2
   342                                      
   343 00000010 B801000000                  mov eax,SYS_PRINT
   344 00000015 BB07000000                  mov ebx, DEFAULT_ATTRIBUTES
   345 0000001A B901000000                  mov ecx, COUNT_T2_Y
   346 0000001F BA00000000                  mov edx, 0
   347 00000024 BE[8A000000]                mov esi, .msg_task2
   348 00000029 CD80                        int 0x80
   349                                      
   350                                      .normal_t2:
   351 0000002B B803000000                  mov eax, SYS_GET_SCANCODE
   352 00000030 CD80                        int 0x80
   353 00000032 3DB0000000                  cmp eax,SC_BREAK_B
   354 00000037 753F                        jne .fin
   355                                      
   356 00000039 FF05[7B000000]              inc dword[.task2_count] ; incremento la variable que cuenta las pulsadas
   357                                      
   358 0000003F B804000000                  mov eax, SYS_SET_SCANCODE
   359 00000044 BB00000000                  mov ebx, 0x00; limpio el scan_code_actual, lo pongo en 0x00
   360 00000049 CD80                        int 0x80
   361                                  
   362 0000004B B805000000                  mov eax, SYS_ITOA
   363 00000050 BB[7F000000]                mov ebx, .buffer_itoa_t2
   364 00000055 8B0D[7B000000]              mov ecx, [.task2_count]
   365 0000005B CD80                        int  0x80
   366                                          
   367 0000005D B801000000                  mov eax,SYS_PRINT
   368 00000062 BB07000000                  mov ebx, DEFAULT_ATTRIBUTES
   369 00000067 B901000000                  mov ecx, COUNT_T2_Y
   370 0000006C BA44000000                  mov edx, COUNT_T2_X
   371 00000071 BE[7F000000]                mov esi, .buffer_itoa_t2
   372 00000076 CD80                        int 0x80
   373                                  
   374                                      .fin:
   375                                      ;mov eax,SYS_HLT
   376                                      ;int 0x80
   377 00000078 EB86                    jmp task2
   378 0000007A 00                      .task2_init db 0x00
   379 0000007B 00000000                .task2_count dd 0x00
   380 0000007F 00<rept>                .buffer_itoa_t2 times 11 db 0x00
   381 0000008A 546172656120322065-     .msg_task2 db "Tarea 2 ejecutandose, Cantidad de veces que se presiono la letra B:",0
   382 00000093 6A65637574616E646F-
   383 0000009C 73652C2043616E7469-
   384 000000A5 646164206465207665-
   385 000000AE 636573207175652073-
   386 000000B7 652070726573696F6E-
   387 000000C0 6F206C61206C657472-
   388 000000C9 6120423A00         
   389                                  
   390                                  SECTION .task3_code progbits
   391                                  task3:
   392 00000000 0F6E0D[76000000]            movd mm1,[.task3_count]
   393 00000007 803D[75000000]00            cmp byte[.task3_init],0x00 ; no se inició todavía
   394 0000000E 7522                        jne .normal_t3
   395                                      
   396 00000010 FF35[D6000000]              push dword[atributos]
   397 00000016 6A02                        push COUNT_T3_Y
   398 00000018 FF35[DE000000]              push dword[columna]
   399 0000001E 68[85000000]                push .msg_task3
   400 00000023 E8(00000000)                call print
   401 00000028 83C410                      add esp,16
   402 0000002B C605[75000000]01            mov byte[.task3_init],0x01
   403                                      
   404                                      .normal_t3:
   405 00000032 803D[CF000000]AE            cmp byte[scan_code_actual],SC_BREAK_C
   406 00000039 7537                        jne .fin
   407                                      
   408 0000003B FF05[76000000]              inc dword[.task3_count] ; incremento la variable que cuenta las pulsadas
   409 00000041 C605[CF000000]00            mov byte[scan_code_actual],0x00; limpio el scan_code_actual
   410 00000048 68[7A000000]                push .buffer_itoa_t3
   411 0000004D FF35[76000000]              push dword[.task3_count]
   412 00000053 E8(4A000000)                call itoa
   413 00000058 83C408                      add esp,8;add esp,8; bajo el esp los 2 push
   414                                  
   415 0000005B FF35[D6000000]              push dword[atributos]
   416 00000061 6A02                        push COUNT_T3_Y
   417 00000063 6A44                        push COUNT_T3_X
   418 00000065 68[7A000000]                push .buffer_itoa_t3
   419 0000006A E8(00000000)                call print; 
   420 0000006F 83C410                      add esp,16; balo el esp los 4 push
   421                                      .fin:
   422 00000072 F4                          hlt
   423 00000073 EB8B                    jmp task3
   424 00000075 00                      .task3_init db 0x00
   425 00000076 00000000                .task3_count dd 0x00
   426 0000007A 00<rept>                .buffer_itoa_t3 times 11 db 0x00
   427 00000085 546172656120332065-     .msg_task3 db "Tarea 3 ejecutandose, Cantidad de veces que se presiono la letra C:",0
   428 0000008E 6A65637574616E646F-
   429 00000097 73652C2043616E7469-
   430 000000A0 646164206465207665-
   431 000000A9 636573207175652073-
   432 000000B2 652070726573696F6E-
   433 000000BB 6F206C61206C657472-
   434 000000C4 6120433A00         
   435                                  
   436                                  ;FUNCIONES AGREGADAS
   437                                  SECTION .func progbits
   438                                  ;********************************************************************************
   439                                  ; FUNCION PRINT
   440                                  ;********************************************************************************
   441                                  ;void print(char *string_ptr, char columna, char fila, char color)
   442                                  ;Recibe:
   443                                  ; EIP de regreso: EBP+4
   444                                  ; sting_ptr: EBP+8
   445                                  ; columna: EBP+12
   446                                  ; fila: EBP+16
   447                                  ; color: EBP+20
   448                                  print:
   449 00000000 55                          push ebp; guardo el base pointer original.
   450 00000001 89E5                        mov ebp, esp; cargo el stack pointer en el base pointer.
   451                                      
   452                                      ;La pantalla es de 80x25, debo hacer fila*80+columna para obtener la posición.
   453 00000003 B8A0000000                  mov eax, 160; cargo en eax la la cantidad de caracteres por fila*2 ya que cada caracter ocupa 2 bytes
   454 00000008 8B5D10                      mov ebx, [EBP+16]; cargo en ebx (EBP+16) en la cual quiero escribir y se lo guarda en edx:eax. (aquí estaría en la columna cero).
   455 0000000B F7E3                        mul ebx;
   456 0000000D 03450C                      add eax,[EBP+12]; le sumo la columna.
   457 00000010 03450C                      add eax,[EBP+12]; le sumo la columna una segunda vez ya que cada caracter ocupa 2 bytes!!
   458 00000013 0500800B00                  add eax, VIDEO_BASE_ADDRESS; le sumo la base de video. Con lo que me queda la dirección de memoria
   459 00000018 89C7                        mov edi, eax ;cargo en el di la direccion inicial de memoria sobre la que debo escribir!. edi tendra la direccion donde debo empezar a escribir
   460 0000001A 8B7508                      mov esi, [EBP+8];cargo en el si la direccion de donde comenzaré a sacar los caracteres. esi tendra la direccion donde tengo el primer caracter del texto
   461                                      
   462                                      
   463                                  ciclo_print:
   464 0000001D 8A06                        mov al,byte[esi]
   465 0000001F 8807                        mov byte[edi],al;copio el primer caracter del texto en la primera posicion de memoria
   466 00000021 8A4514                      mov al,byte[EBP+20]
   467 00000024 884701                      mov byte[edi+1],al;copio el color correspondiente en la segunda
   468 00000027 83C702                      add edi,2 ;incremento la posicion del destino en 2
   469 0000002A 83C601                      add esi,1; incremento la posicion de la fuente en 1
   470 0000002D 803E00                      cmp byte[esi],0
   471 00000030 75EB                        jne ciclo_print
   472                                  
   473                                  fin_print:
   474 00000032 5D                          pop ebp; recupero el valor de ebp original
   475 00000033 C3                          ret
   476                                      
   477                                  
   478                                  ;********************************************************************************
   479                                  ; FUNCION CLRSCR
   480                                  ;********************************************************************************
   481                                  ;void clrscr(void)
   482                                  ;Recibe: NADA 
   483                                  clrscr:
   484 00000034 B000                        mov al, 0; caracter nulo
   485 00000036 B407                        mov ah, DEFAULT_ATTRIBUTES; atributos por defecto.
   486 00000038 BF00800B00                  mov edi, VIDEO_BASE_ADDRESS
   487 0000003D 66B9D007                    mov cx,25*80; cargo en cx el tamaño de la pantalla en "numero de caracteres"
   488                                      
   489                                  ciclo_clear:
   490 00000041 668907                      mov word[edi], ax; copio el caracter en la memoria de video
   491 00000044 83C702                      add edi,2; incremento dos posicicones ya que cada caracter ocupa 2!
   492 00000047 E2F8                        loop ciclo_clear
   493                                  
   494                                  fin_clear:
   495 00000049 C3                          ret
   496                                  
   497                                  ;********************************************************************************
   498                                  ; FUNCION ITOA (convierte ascii a entero)
   499                                  ;********************************************************************************
   500                                  ;char* itoa(int valor, char* string)
   501                                  ;Recibe: EIP de regreso (EBP+4)
   502                                  ;int valor (EBP+8)
   503                                  ;char* string (EBP+12)
   504                                  itoa:
   505 0000004A 55                          push ebp; guardo el ebp original
   506 0000004B 89E5                        mov ebp,esp; me muevo por la pila con ebp
   507                                      
   508 0000004D 8B4508                      mov eax, [ebp+8]; cargo en eax el valor entero
   509                                      
   510 00000050 31D2                        xor edx,edx; pongo edx en cero
   511 00000052 B90A000000                  mov ecx,10; pongo 10 en ecx, que es la cantidad maxima de cifras que puede tener un entero
   512                                      
   513 00000057 8B7D0C                      mov edi, [ebp+12]; coloco el puntero de la base de la cadena en el registro de destino
   514                                      
   515                                  ciclo_itoa:
   516 0000005A BB0A000000                  mov ebx,10 ; cargo ebx con 10
   517 0000005F F7F3                        div ebx; eax/10
   518 00000061 83C230                      add edx,48; en edx esta el resto, le sumo 48 para pasarlo a ascii
   519 00000064 89D3                        mov ebx,edx; muevo el ascii a ebx
   520 00000066 885C0FFF                    mov [edi+ecx-1],bl; muevo el ascii al string caracter, empiezo desde la ultima cifra!
   521 0000006A 31D2                        xor edx,edx; limpio edx para que no afecte la proxima division
   522 0000006C 49                          dec ecx; decremento ecx en 1
   523 0000006D 83F800                      cmp eax,0; es cero?
   524 00000070 75E8                        jne ciclo_itoa
   525                                      
   526                                  inversion_itoa: ;debo invertir la cadena ya que con este algoritmo se carga en sentido inverso
   527 00000072 89FE                        mov esi,edi; cargo destino con origen
   528 00000074 01CE                        add esi,ecx; le sumo a la fuente ecx de esta forma me paro en el ultimo digito copiado!
   529                                      
   530 00000076 BB0B000000                  mov ebx,11
   531 0000007B 29CB                        sub ebx,ecx; (11-ecx, de esta forma conozco la cantidad de digitos a mover, para incluso mover el caracter nulo!)
   532 0000007D 89D9                        mov ecx,ebx; pongo esa cifra en ecx
   533                                      
   534 0000007F F3A4                        rep movsb; muevo 10-ecx bytes de si a di
   535                                  
   536                                  fin_itoa:   
   537 00000081 5D                          pop ebp
   538 00000082 C3                          ret
   539                                  
   540                                  
   541                                  ;********************************************************************************
   542                                  ; RUTINA PARA GENERAR DIRECCIONES ALEATORIAS
   543                                  ;********************************************************************************
   544                                  ;Devuelve en eax una direccion de  32 bits generada de manera aleatoeria
   545                                  
   546                                  gen_random_addr32:
   547 00000083 EB04                        jmp .inicio_gen_addr
   548 00000085 00000000                    .semilla: dd 0x00
   549                                      .inicio_gen_addr:
   550 00000089 B8A1B0B912                    mov eax, 314159265
   551 0000008E F725[85000000]                mul dword [.semilla]
   552 00000094 0515CD5B07                    add eax, 123456789
   553 00000099 A3[85000000]                  mov [.semilla],eax
   554 0000009E BA00000010                    mov edx,0x10000000; quiero que el  maximo numero sea 0x1000000!!
   555 000000A3 81EA00004000                  sub edx,0x00400000; le resto 0x400000 ya que NO quiero direcciones lineales de la primera. 
   556 000000A9 F7E2                          mul edx; De esta manera generare un numero entre 0x00 y 0x0FC00000
   557 000000AB 81C200004000                  add edx, 0x00400000; pero lo que yo quiero es entre 0x00400000 y 0x10000000, entonces le sumo 0x00400000
   558 000000B1 89D0                          mov eax,edx; por abi 32 el retorno va en eax
   559 000000B3 C3                          ret
   560                                  
   561                                  
   562                                  ;********************************************************************************
   563                                  ; RUTINAS PARA GENERAR EXCEPCIONES
   564                                  ;********************************************************************************
   565                                  generar_DE: ;division por cero
   566 000000B4 BB00000000                  mov ebx, 0
   567 000000B9 B80A000000                  mov eax, 10
   568 000000BE F7F3                        div ebx
   569 000000C0 C3                          ret
   570                                  
   571                                  generar_UD:
   572 000000C1 FF                          db 0xFF
   573 000000C2 FF                          db 0xFF
   574 000000C3 C3                          ret
   575                                      
   576                                  generar_DF:
   577 000000C4 66C705[02000000]00-         mov word[IDT32+8*0+2],0x00 ;rompo el selector de codigo del descriptor de la excepcion cero!, lo mando al nulo
   578 000000CC 00                 
   579 000000CD BB00000000                  mov ebx,0
   580 000000D2 B80A000000                  mov eax,10
   581 000000D7 F7F3                        div ebx; genero excepcion cero, como encontrara el descriptor roto, hara doble falta
   582 000000D9 C3                          ret
   583                                      
   584                                  generar_GP:
   585                                      ;De esta manera genero un mensaje de error con el indice del descriptor en la GDT! (en este caso 1, ya que corresponde a la entrada 1)
   586 000000DA 66B80800                    mov ax, 0x08
   587 000000DE 8EC0                        mov es, ax; cargo el extra segment con el indice del segmento de codigo!
   588 000000E0 268900                      mov [es:eax],eax ; intento escribir en el segmento de codigo!! 
   589                                      
   590                                      ;jmp 0x00:0x00 ; salto al selector nulo!!
   591 000000E3 C3                          ret
   592                                  
   593                                  generar_PF: ;hasta no ver paginacion no lo podemos hacer....
   594 000000E4 E9(000000F0)                jmp 0xF0000000 ; intento saltar a un lugar que no habilite en la paginacion...
   595 000000E9 C3                          ret
   596                                  
   597                                  
   598                                  ;--------------------------------------------------------------------------------
   599                                  ;Escape presionado  
   600                                  ;--------------------------------------------------------------------------------    
   601                                  esc_presionada:
   602 000000EA E845FFFFFF                call clrscr
   603                                      
   604 000000EF FF35[D6000000]            push dword[atributos]
   605 000000F5 FF35[DA000000]            push dword[fila]
   606 000000FB FF35[DE000000]            push dword[columna]
   607 00000101 68[2B010000]              push msg_ej6
   608                                  
   609 00000106 E8F5FEFFFF                call print;
   610 0000010B 83C410                    add esp,16; bajo los 4 push
   611 0000010E F4                        hlt 
   612 0000010F C3                        ret  
   613                                  ;--------------------------------------------------------------------------------
   614                                  ; Handlers de excepciones
   615                                  ;--------------------------------------------------------------------------------
   616                                  handler_excep0:
   617                                      
   618 00000110 E81FFFFFFF                  call clrscr
   619                                      
   620 00000115 FF35[D6000000]              push dword[atributos]
   621 0000011B FF35[DA000000]              push dword[fila]
   622 00000121 FF35[DE000000]              push dword[columna]
   623 00000127 68[40010000]                push msg_excep0
   624                                      
   625 0000012C E8CFFEFFFF                  call print; 
   626 00000131 F4                          hlt;
   627 00000132 CF                          iret
   628                                  
   629                                  handler_excep1:
   630 00000133 CF                          iret
   631                                  
   632                                  handler_excep2:
   633 00000134 CF                          iret
   634                                      
   635                                  handler_excep3:
   636 00000135 CF                          iret
   637                                  
   638                                  handler_excep4:
   639 00000136 CF                          iret
   640                                  
   641                                  handler_excep5:
   642 00000137 CF                          iret
   643                                  
   644                                  handler_excep6: ;(invalid opcode)
   645 00000138 E8F7FEFFFF                  call clrscr
   646                                      
   647 0000013D FF35[D6000000]              push dword[atributos]
   648 00000143 FF35[DA000000]              push dword[fila]
   649 00000149 FF35[DE000000]              push dword[columna]
   650 0000014F 68[5F010000]                push msg_excep6
   651                                      
   652 00000154 E8A7FEFFFF                  call print; 
   653 00000159 F4                          hlt;
   654 0000015A CF                          iret
   655                                  
   656                                  handler_excep7:
   657                                  ;AQUI SE ENTRARA CUANDO LA TAREA ACTUAL EJECUTE UNA INSTRUCCION SIMD! 
   658                                  ;POR LO TANTO DEBO RECUPERAR SU CONTEXTO SIMD ANTERIOR
   659 0000015B 60                          pushad
   660                                      
   661 0000015C 0F20C0                      mov eax,cr0
   662 0000015F BB08000000                  mov ebx, 0x08
   663 00000164 F7D3                        not ebx
   664 00000166 21D8                        and eax,ebx
   665 00000168 0F22C0                      mov cr0,eax;limpio en cr0 el bit de TS!!
   666                                      
   667 0000016B 0F20D8                      mov eax,cr3; cargo en eax el arbol de páginas, esto me dirá cual es la tarea actualmente en ejecución
   668 0000016E 3B05[F5010000]              cmp eax,[task_pds]; El cr3 cargado se corresponde con el de la tarea 1
   669 00000174 7412                        je .tarea1
   670 00000176 3B05[F9010000]              cmp eax,[task_pds+4]; El cr3 cargado se corresponde con el de la tarea 2
   671 0000017C 7414                        je .tarea2 
   672 0000017E 3B05[FD010000]              cmp eax,[task_pds+8]; El cr3 cargado se corresponde con el de la tarea 2   
   673 00000184 7416                        je .tarea3
   674 00000186 EB1E                        jmp .fin
   675                                      
   676                                      .tarea1:
   677 00000188 A1[31020000]                mov eax, [task_SIMD]
   678 0000018D 0FAE08                      fxrstor [eax]
   679 00000190 EB14                        jmp .fin
   680                                      
   681                                      .tarea2:
   682 00000192 A1[35020000]                mov eax, [task_SIMD+4]
   683 00000197 0FAE08                      fxrstor [eax]
   684 0000019A EB0A                        jmp .fin
   685                                      
   686                                      .tarea3:
   687 0000019C A1[39020000]                mov eax,[task_SIMD+8]; aca muevo el puntero al contexto de las simd!!
   688 000001A1 0FAE08                      fxrstor [eax]
   689 000001A4 EB00                        jmp .fin
   690                                      
   691                                  .fin:
   692 000001A6 61                          popad
   693 000001A7 CF                          iret
   694 000001A8 00000000                .context_SIMD dd 0x00
   695                                  
   696                                  handler_excep8: ;(double fault)
   697 000001AC 5A                          pop edx; popeo el codigo de error
   698                                      
   699 000001AD E882FEFFFF                  call clrscr
   700                                      
   701 000001B2 FF35[D6000000]              push dword[atributos]
   702 000001B8 FF35[DA000000]              push dword[fila]
   703 000001BE FF35[DE000000]              push dword[columna]
   704 000001C4 68[89010000]                push msg_excep8
   705                                      
   706 000001C9 E832FEFFFF                  call print; 
   707 000001CE F4                          hlt;
   708 000001CF CF                          iret
   709                                  
   710                                  handler_excep9:
   711 000001D0 CF                          iret
   712                                  
   713                                  handler_excep10: ;(con Codigo de error)
   714 000001D1 5A                          pop edx; popeo el codigo de error
   715 000001D2 CF                          iret
   716                                  
   717                                  handler_excep11:
   718 000001D3 5A                          pop edx; popeo el codigo de error
   719 000001D4 CF                          iret
   720                                  
   721                                  handler_excep12:
   722 000001D5 5A                          pop edx; popeo el codigo de error
   723 000001D6 CF                          iret
   724                                  
   725                                  handler_excep13: ;(General protection fault)
   726 000001D7 5A                          pop edx; popeo el codigo de error
   727                                      
   728 000001D8 E857FEFFFF                  call clrscr
   729                                      
   730 000001DD FF35[D6000000]              push dword[atributos]
   731 000001E3 FF35[DA000000]              push dword[fila]
   732 000001E9 FF35[DE000000]              push dword[columna]
   733 000001EF 68[AA010000]                push msg_excep13
   734                                      
   735 000001F4 E807FEFFFF                  call print; 
   736 000001F9 F4                          hlt;
   737 000001FA CF                          iret
   738                                  
   739                                  handler_excep14:
   740                                      ;Conservo en: eax = Direccion lineal (SOLO TEMPORALMENTE)
   741                                      ;             edx = direccion lineal desplazada 22 bits. Es decir entrada del directorio de paginas
   742                                      ;             ecx = Entrada de la tabla de paginas (bits 21 a 12)
   743                                      
   744                                      
   745 000001FB 5A                          pop edx; popeo el codigo de error
   746                                      
   747 000001FC 60                          pushad
   748                                      
   749 000001FD E915010000                  jmp .alocar_pagina
   750                                      
   751 00000202 457863657063696F6E-         .msg_pise_rom db "Excepcion 14: Fallo de pagina, intento de acceso fuera de rango",0
   752 0000020B 2031343A2046616C6C-
   753 00000214 6F2064652070616769-
   754 0000021D 6E612C20696E74656E-
   755 00000226 746F20646520616363-
   756 0000022F 65736F206675657261-
   757 00000238 2064652072616E676F-
   758 00000241 00                 
   759 00000242 457863657063696F6E-         .msg_pise_mem_cableada db "Excepcion 14: Fallo de pagina, intento fallido de acceso a memoria mapeada",0
   760 0000024B 2031343A2046616C6C-
   761 00000254 6F2064652070616769-
   762 0000025D 6E612C20696E74656E-
   763 00000266 746F2066616C6C6964-
   764 0000026F 6F2064652061636365-
   765 00000278 736F2061206D656D6F-
   766 00000281 726961206D61706561-
   767 0000028A 646100             
   768 0000028D 457863657063696F6E-         .msg_pagina_alocada db "Excepcion 14: Fallo de pagina, Pagina no presente, se asigno una pagina nueva",0
   769 00000296 2031343A2046616C6C-
   770 0000029F 6F2064652070616769-
   771 000002A8 6E612C20506167696E-
   772 000002B1 61206E6F2070726573-
   773 000002BA 656E74652C20736520-
   774 000002C3 617369676E6F20756E-
   775 000002CC 6120706167696E6120-
   776 000002D5 6E7565766100       
   777 000002DB 457863657063696F6E-         .msg_pagina_presente db "Excepcion 14: Pagina PRESENTE, se debe a otra cosa...",0
   778 000002E4 2031343A2050616769-
   779 000002ED 6E612050524553454E-
   780 000002F6 54452C207365206465-
   781 000002FF 62652061206F747261-
   782 00000308 20636F73612E2E2E00 
   783                                      
   784                                      
   785 00000311 EB04                        jmp .alocar_pagina
   786                                      
   787 00000313 00004000                    .phys_mem_actual dd  0x400000; las direcciones fisicas arrancan en 0x400000!
   788                                      
   789                                      .alocar_pagina:
   790 00000317 0F20D0                      mov eax,cr2; en CR2 quedo la direccion lineal que causó el fallo de pagina
   791 0000031A 89C2                        mov edx,eax
   792 0000031C C1EA16                      shr edx,22; si quiero saber a que entrada del DIRECTORIO pertenece, debo quedarme con los primeros 10 bits.
   793 0000031F 89C1                        mov ecx,eax;
   794 00000321 C1E90C                      shr ecx,12; elimino los 12 bits menos significativos
   795 00000324 81E1FF030000                and ecx, 0x3FF; con esto elimino los 10 MSb, que corresponden al directorio y me quedo con la entrada de la TABLA
   796                                       
   797 0000032A 3D00000010                  cmp eax, 0x10000000 ;pongo un limite a las direcciones virtuales, para no pisar las tablas de paginas que estan con identity mapping. Si excede esto se va
   798 0000032F 0F8790000000                ja .fuera_de_rango
   799                                      
   800 00000335 83FA00                      cmp edx,0; si pertenece a la entrada 0...
   801 00000338 0F84AD000000                je .pise_mem_cableada
   802                                      
   803                                      ;consulto si la entrada del directorio esta presente
   804 0000033E F70495[00000000]01-         test dword[PAGE_DIR_SO+edx*4], 0x01
   805 00000346 000000             
   806 00000349 7402                        jz .tabla_no_presente
   807 0000034B EB1D                        jmp .cargar_tabla
   808                                   
   809                                      .tabla_no_presente:
   810 0000034D 89D3                        mov ebx,edx; cargo el indice dentro del directorio de paginas en ebx
   811 0000034F C1E30C                      shl ebx,12; multiplico por 4096 para obtener la posicion de memoria dentro de las multiples tablas de paginas!!!
   812 00000352 8D9B[00F0FFFF]              lea ebx,[PAGE_TABLES1_40_SO-4096+ebx]; cargo en ebx la memoria fisica correspondiente a la posicion en la tabla.
   813 00000358 81E300F0FFFF                and ebx, 0xFFFFF000; por las dudas borro los 12LSb, ya que tiene que quedar multiplo de 4k en memoria fisica!!.
   814 0000035E 83CB03                      or ebx,0x03; le seteo los atributos en Lectura/Escritura y Presente
   815 00000361 891C95[00000000]            mov [PAGE_DIR_SO+edx*4],ebx; Cargo en la entrada del directorio que corresponda, la ubicacion fisica de la nueva tabla de paginas!.
   816 00000368 EB00                        jmp .cargar_tabla
   817                                      
   818                                      .cargar_tabla:
   819 0000036A 89D3                        mov ebx,edx
   820 0000036C C1E30C                      shl ebx,12
   821 0000036F F783[00F0FFFF]0100-         test dword[PAGE_TABLES1_40_SO-4096+ebx],0x01; compruebo si el bit de presente la pagina esta encendido o no!!
   822 00000377 0000               
   823 00000379 0F8592000000                jnz .pagina_presente
   824 0000037F A1[13030000]                mov eax,[.phys_mem_actual]; la nueva pagina se coloca en las siguientes posiciones de memoria!!
   825 00000384 2500F0FFFF                  and eax,0xFFFFF000; limpio los 12LSb por las dudas, ya que la pagina debe estar en multiplo de 4k!!
   826 00000389 83C803                      or eax,0x03 ; seteo el bit de presente y Lectura/Escritura
   827 0000038C 8D9B[00F0FFFF]              lea ebx,[PAGE_TABLES1_40_SO-4096+ebx]
   828 00000392 89048B                      mov [ebx+ecx*4], eax;cargo la entrada correspondiente de la tabla!!
   829 00000395 8105[13030000]0010-         add dword[.phys_mem_actual],0x1000; Incremento la posicion de memoria fisica actual en 4k!!
   830 0000039D 0000               
   831                                      
   832 0000039F E890FCFFFF                  call clrscr
   833                                      
   834 000003A4 FF35[D6000000]              push dword[atributos]
   835 000003AA FF35[DA000000]              push dword[fila]
   836 000003B0 FF35[DE000000]              push dword[columna]
   837 000003B6 68[8D020000]                push .msg_pagina_alocada
   838                                      
   839 000003BB E840FCFFFF                  call print; 
   840 000003C0 83C410                      add esp,16
   841 000003C3 EB75                        jmp .fin_ok
   842                                      
   843                                      .fuera_de_rango:
   844                                      
   845 000003C5 E86AFCFFFF                  call clrscr
   846                                      
   847 000003CA FF35[D6000000]              push dword[atributos]
   848 000003D0 FF35[DA000000]              push dword[fila]
   849 000003D6 FF35[DE000000]              push dword[columna]
   850 000003DC 68[02020000]                push .msg_pise_rom
   851                                      
   852 000003E1 E81AFCFFFF                  call print; 
   853 000003E6 83C410                      add esp,16
   854 000003E9 EB4C                        jmp .fin_error
   855                                      
   856                                      .pise_mem_cableada:
   857                                      
   858 000003EB E844FCFFFF                  call clrscr
   859                                      
   860 000003F0 FF35[D6000000]              push dword[atributos]
   861 000003F6 FF35[DA000000]              push dword[fila]
   862 000003FC FF35[DE000000]              push dword[columna]
   863 00000402 68[42020000]                push .msg_pise_mem_cableada
   864                                      
   865 00000407 E8F4FBFFFF                  call print;
   866 0000040C 83C410                      add esp,16
   867 0000040F EB26                        jmp .fin_error
   868                                      
   869                                      .pagina_presente:
   870                                      
   871 00000411 E81EFCFFFF                  call clrscr
   872                                      
   873 00000416 FF35[D6000000]              push dword[atributos]
   874 0000041C FF35[DA000000]              push dword[fila]
   875 00000422 FF35[DE000000]              push dword[columna]
   876 00000428 68[DB020000]                push .msg_pagina_presente
   877                                      
   878 0000042D E8CEFBFFFF                  call print;
   879 00000432 83C410                      add esp,16
   880 00000435 EB03                        jmp .fin_ok
   881                                      
   882                                      .fin_error:
   883 00000437 F4                          hlt;
   884 00000438 61                          popad
   885 00000439 CF                          iret
   886                                      
   887                                      .fin_ok:
   888 0000043A 61                          popad
   889 0000043B CF                          iret
   890                                      
   891                                  ;Se saltea la 15, es reservada
   892                                  handler_excep16:
   893 0000043C CF                          iret
   894                                      
   895                                  handler_excep17:
   896 0000043D 5A                          pop edx; popeo el codigo de error
   897 0000043E CF                          iret
   898                                      
   899                                  handler_excep18:
   900 0000043F CF                          iret
   901                                      
   902                                  handler_excep19:
   903 00000440 CF                          iret
   904                                      
   905                                  handler_excep20:
   906 00000441 CF                          iret
   907                                  
   908                                  ;Se saltea 21-29, son reservadas
   909                                  
   910                                  handler_excep30:
   911 00000442 5A                          pop edx; popeo el codigo de error
   912 00000443 CF                          iret
   913                                      
   914                                  ;Se saltea la 31, es reservada
   915                                  
   916                                  ;--------------------------------------------------------------------------------
   917                                  ; Handlers de interrupciones
   918                                  ;--------------------------------------------------------------------------------
   919                                  handler_interr0: ;handler del timer, es decir el SCHEDULER
   920                                  
   921                                      
   922 00000444 803D[F2010000]00            cmp byte[task_init+0],0x00; la tarea 1 NO esta inicializada
   923 0000044B 7417                        je .init_task
   924 0000044D 803D[F3010000]00            cmp byte[task_init+1],0x00; la tarea 2 NO esta inicializada
   925 00000454 740E                        je .init_task
   926 00000456 803D[F4010000]00            cmp byte[task_init+2],0x00; la tarea 3 NO esta inizialidada
   927 0000045D 7405                        je .init_task
   928                                      
   929 0000045F E970010000                  jmp .task_switch ;si ya quedaron todas las tareas inicializadas...va directamente a conmutar
   930                                      
   931                                      .init_task:
   932 00000464 833D[A1060000]00            cmp dword[.task_actual], 0x00; si task_actual es 0, es porque es la primera vez que entra al handler!, entonces no debo salvar el contexto...
   933 0000046B 744F                        je .calc_next_task
   934                                      
   935                                      ;sino es la tarea 1... entonces debo salvar el contexto de la tarea de la cual provengo.
   936 0000046D 50                          push eax ; pusheo el valor de eax para resguardarlo
   937 0000046E A1[A1060000]                mov eax,dword[.task_actual]
   938 00000473 8B0485[21020000]            mov eax,[task_contexts+eax*4-4]; en eax tengo ahora el puntero al contexto.
   939                                      ;En este orden se guardan: EAX,ECX,EDX,EBX,EBP,ESI,EDI,ES,DS,FS y GS
   940 0000047A 8F00                        pop dword[eax+4*0]; guardo el valor de eax en el contexto
   941 0000047C 894804                      mov [eax+4*1],ecx
   942 0000047F 895008                      mov [eax+4*2],edx
   943 00000482 89580C                      mov [eax+4*3],ebx
   944 00000485 896810                      mov [eax+4*4],ebp
   945 00000488 897014                      mov [eax+4*5],esi
   946 0000048B 897818                      mov [eax+4*6],edi
   947 0000048E 89601C                      mov [eax+4*7],esp
   948 00000491 8C5020                      mov [eax+4*8+2*0],ss
   949 00000494 8C4022                      mov [eax+4*8+2*1],es
   950 00000497 8C5824                      mov [eax+4*8+2*2],ds
   951 0000049A 8C6026                      mov [eax+4*8+2*3],fs
   952 0000049D 8C6828                      mov [eax+4*8+2*4],gs
   953 000004A0 0F20C0                      mov eax,cr0
   954 000004A3 83E008                      and eax,0x08; Me fijo si el TS está en 1 o en 0
   955 000004A6 83F800                      cmp eax, 0x00; si está en 0... es porque entró a la excepcion 7, debo salvar el contexto!
   956 000004A9 7402                        je .save_simd
   957 000004AB EB0F                        jmp .calc_next_task
   958                                      
   959                                      .save_simd:
   960 000004AD A1[A1060000]                mov eax,[.task_actual]
   961 000004B2 8B1C85[2D020000]            mov ebx,[task_SIMD+eax*4-4]
   962 000004B9 0FAE03                      fxsave [ebx]
   963                                      
   964                                     .calc_next_task:
   965 000004BC A1[A1060000]                mov eax,[.task_actual]
   966 000004C1 31D2                        xor edx,edx ;limpio edx
   967 000004C3 BB03000000                  mov ebx,0x03
   968 000004C8 F7F3                        div ebx ; si eax es 0, el resto es cero, si eax es 1, el resto es 1, si eax es 2, el resto es 2, si eax es 3, el resto es 0 de vuelta y así suscesivamente.
   969 000004CA 89D0                        mov eax,edx;
   970 000004CC 83C001                      add eax,1; acá finalmente en eax dejo 1,2 o 3 (la tarea actual)
   971 000004CF A3[A1060000]                mov [.task_actual],eax; actualizo el valor de task actual con eax.
   972                                      
   973                                      ;SETEO EL CR0.TS por el cambio de tarea
   974 000004D4 0F20C3                      mov ebx,cr0
   975 000004D7 83CB08                      or ebx, 0x08; seteo el bit 3, es decir TS=1
   976 000004DA 0F22C3                      mov cr0,ebx
   977 000004DD A1[A1060000]                mov eax,[.task_actual]; recupero en eax el valor de la tarea actual
   978                                      
   979 000004E2 833C85[39020000]03          cmp dword[task_priv+eax*4-4],0x03
   980 000004EA 7460                        je .load_task_usuario ;si la tarea es de usuario... (PL=3)
   981 000004EC EB00                        jmp .load_task_kernel ;si la tarea es de "kernel"... (PL=/=3) ya que en TD3 no usamos ni PL=1 ni PL=2
   982                                      
   983                                      .load_task_kernel:
   984                                      ;RECUPERO LO QUE ENTRO A LA PILA CON LA INTERRUPCION DE kernel->kernel, SOLO ME INTERESAN LOS FLAGS
   985 000004EE 5A                          pop edx; EIP
   986 000004EF 5A                          pop edx; CS
   987 000004F0 59                          pop ecx; aquí queda el EFLAGS que es el unico registro que me interesa!!!
   988                                      ;INICIALIZO LOS SELECTORES DE KERNEL
   989 000004F1 66B8[0000]                  mov ax,SEL_DATOS
   990 000004F5 8ED0                        mov ss,ax
   991 000004F7 8EC0                        mov es,ax
   992 000004F9 8ED8                        mov ds,ax
   993                                      ;INICIALIZO LA PILA, CAMBIO EL CR3 y ACTUALIZO EL ESTADO DE LAS TAREAS
   994 000004FB A1[A1060000]                mov eax,[.task_actual]
   995 00000500 8B2485[FD010000]            mov esp,[task_stacks_kernel+eax*4-4]; cambio la pila
   996 00000507 8B1C85[F1010000]            mov ebx,[task_pds+eax*4-4]; cargo en ebx el nuevo cr3
   997 0000050E 0F22DB                      mov cr3,ebx ; cambio el arbol de paginacion
   998 00000511 8B1C85[15020000]            mov ebx, [task_list+eax*4-4]; cargo la posición de inicio de la tarea en cuestión en ebx
   999 00000518 C680[F1010000]01            mov byte[task_init+eax-1],0x01 ; la tarea queda inicializada!
  1000                                      ;ACTUALIZO LA UNICA TSS
  1001 0000051F 8B1485[FD010000]            mov edx,dword[task_stacks_kernel+eax*4-4]
  1002 00000526 8915[04000000]              mov dword[tss_tt+0x04],edx
  1003 0000052C 66C705[08000000]-           mov word[tss_tt+0x08],SEL_DATOS
  1004 00000533 [0000]             
  1005                                      ;CARGO EN LA PILA LOS FLAGS, EL SELECTOR DE CODIGO Y EL EIP para luego ejecutar el EOI y el IRET
  1006 00000535 83EC08                      sub esp,8
  1007 00000538 894C2408                    mov [esp+8],ecx
  1008 0000053C C7442404[00000000]          mov dword[esp+4], SEL_CODIGO
  1009 00000544 891C24                      mov [esp],ebx
  1010                                      ;EOI
  1011 00000547 B020                        mov al, 0x20
  1012 00000549 E620                        out 0x20,al ; Marco el EOI
  1013 0000054B CF                          iret
  1014                                      
  1015                                      .load_task_usuario: ;salto con cambio de nivel de privilegio    
  1016                                      ;RECUPERO LO QUE ENTRO EN LA PILA CON LA INTERRUPCION DE usuario->kernel (cambio de PL), SOLO ME INTERESAN LOS FLAGS
  1017 0000054C 5A                          pop edx; EIP
  1018 0000054D 5A                          pop edx; CS
  1019 0000054E 59                          pop ecx; aquí queda el EFLAGS que es el unico registro que me interesa!!!
  1020 0000054F 833D[A1060000]01            cmp dword[.task_actual],0x01; si la tarea es la primera, en la inicializacion viene de kernel (sin cambio de PL)!, así que solo debo popear EIP, CS y EFLAGS!
  1021 00000556 7402                        je .load_task_usuario_cont 
  1022 00000558 5A                          pop edx; ESP
  1023 00000559 5A                          pop edx; SS
  1024                                      .load_task_usuario_cont:
  1025                                      ;INICIALIZO LOS SELECTORES DE USUARIO
  1026 0000055A 66B8[0000]                  mov ax,SEL_DATOS_NP3; Selector de datos de usuario!!!
  1027 0000055E 6683C803                    or ax,0x03; Recordar poner el RPL en 3!!!
  1028 00000562 8EC0                        mov es,ax
  1029 00000564 8ED8                        mov ds,ax
  1030                                      ;INICIALIZO LA PILA de USUARIO, CAMBIO EL CR3 y ACTUALIZO EL ESTADO DE LAS TAREAS
  1031 00000566 A1[A1060000]                mov eax,[.task_actual]
  1032 0000056B 8B2485[09020000]            mov esp,[task_stacks_NP3+eax*4-4]; cambio la pila
  1033 00000572 8B1C85[F1010000]            mov ebx,[task_pds+eax*4-4]; cargo en ebx el nuevo cr3
  1034 00000579 0F22DB                      mov cr3,ebx ; cambio el arbol de paginacion
  1035 0000057C 8B1C85[15020000]            mov ebx, [task_list+eax*4-4]; cargo la posición de inicio de la tarea en cuestión en ebx
  1036 00000583 C680[F1010000]01            mov byte[task_init+eax-1],0x01 ; la tarea queda inicializada!
  1037                                      ;ACTUALIZO LA UNICA TSS
  1038 0000058A 8B1485[FD010000]            mov edx,dword[task_stacks_kernel+eax*4-4]
  1039 00000591 8915[04000000]              mov dword[tss_tt+0x04],edx
  1040 00000597 66C705[08000000]-           mov word[tss_tt+0x08],SEL_DATOS
  1041 0000059E [0000]             
  1042                                      ;CARGO EN LA PILA EL SELECTOR DE DATOS DE USUARIO, EL PUNTERO DE PILA, LOS FLAGS, EL SELECTOR DE CODIGO y EL EIP INICIAL de la tarea 
  1043 000005A0 83EC10                      sub esp,16
  1044 000005A3 C7442410[00000000]          mov dword[esp+16],SEL_DATOS_NP3
  1045 000005AB 834C241003                  or  dword[esp+16],0x03; RPL=3!
  1046 000005B0 8B1485[09020000]            mov edx,dword[task_stacks_NP3+eax*4-4]
  1047 000005B7 8954240C                    mov dword[esp+12],edx
  1048 000005BB 894C2408                    mov dword[esp+8],ecx
  1049 000005BF C7442404[00000000]          mov dword[esp+4],SEL_CODIGO_NP3
  1050 000005C7 834C240403                  or  dword[esp+4],0x03; RPL=3!
  1051 000005CC 891C24                      mov dword[esp],ebx
  1052                                      
  1053 000005CF B020                        mov al, 0x20
  1054 000005D1 E620                        out 0x20,al ; Marco el EOI
  1055                                      
  1056 000005D3 CF                          iret ; salto al inicio de la tarea
  1057                                      
  1058                                      .task_switch: ;aca va a empezar a entrar una vez que se hayan inicializado todas las tareas
  1059                                      ;SALVO EL CONTEXTO DE LA TAREA QUE VENIA CORRIENDO    
  1060 000005D4 50                          push eax ; pusheo el valor de eax para resguardarlo
  1061 000005D5 A1[A1060000]                mov eax,dword[.task_actual]
  1062 000005DA 8B0485[21020000]            mov eax,[task_contexts+eax*4-4]; en eax tengo ahora el puntero al contexto.
  1063                                      ;En este orden se guardan: EAX,ECX,EDX,EBX,EBP,ESI,EDI,ES,DS,FS y GS
  1064 000005E1 8F00                        pop dword[eax+4*0]; guardo el valor de eax en el contexto
  1065 000005E3 894804                      mov [eax+4*1],ecx
  1066 000005E6 895008                      mov [eax+4*2],edx
  1067 000005E9 89580C                      mov [eax+4*3],ebx
  1068 000005EC 896810                      mov [eax+4*4],ebp
  1069 000005EF 897014                      mov [eax+4*5],esi
  1070 000005F2 897818                      mov [eax+4*6],edi
  1071 000005F5 89601C                      mov [eax+4*7],esp
  1072 000005F8 8C5020                      mov [eax+4*8+2*0],ss
  1073 000005FB 8C4022                      mov [eax+4*8+2*1],es
  1074 000005FE 8C5824                      mov [eax+4*8+2*2],ds
  1075 00000601 8C6026                      mov [eax+4*8+2*3],fs
  1076 00000604 8C6828                      mov [eax+4*8+2*4],gs
  1077 00000607 0F20C0                      mov eax,cr0
  1078 0000060A 83E008                      and eax,0x08; Me fijo si el TS está en 1 o en 0
  1079 0000060D 83F800                      cmp eax, 0x00; si está en 0... es porque entró a la excepcion 7, debo salvar el contexto!
  1080 00000610 7402                        je .save_simd_2
  1081 00000612 EB0F                        jmp .calc_next_task_2
  1082                                      
  1083                                      .save_simd_2:
  1084 00000614 A1[A1060000]                mov eax,[.task_actual]
  1085 00000619 8B1C85[2D020000]            mov ebx,[task_SIMD+eax*4-4]
  1086 00000620 0FAE03                      fxsave [ebx]
  1087                                      
  1088                                      .calc_next_task_2:
  1089                                      ;ELIJO Y CAMBIO A LA NUEVA TAREA
  1090 00000623 A1[A1060000]                mov eax,[.task_actual]
  1091 00000628 31D2                        xor edx,edx ;limpio edx
  1092 0000062A BB03000000                  mov ebx, 0x03
  1093 0000062F F7F3                        div ebx ; si eax es 0, el resto es cero, si eax es 1, el resto es 1, si eax es 2, el resto es 2, si eax es 3, el resto es 0 de vuelta y así suscesivamente.
  1094 00000631 89D0                        mov eax,edx;
  1095 00000633 83C001                      add eax,1; acá finalmente en eax dejo 1,2 o 3 (la tarea actual)
  1096 00000636 A3[A1060000]                mov [.task_actual],eax; actualizo el valor de task actual con eax.
  1097                                      ;SETEO EL CR0.TS por el cambio de tarea
  1098 0000063B 0F20C3                      mov ebx,cr0
  1099 0000063E 83CB08                      or ebx, 0x08; seteo el bit 3, es decir TS=1
  1100 00000641 0F22C3                      mov cr0,ebx
  1101 00000644 A1[A1060000]                mov eax,[.task_actual]; recupero en eax el valor de la tarea actual
  1102                                      
  1103                                      ;CAMBIO EL SP0 en la TSS
  1104 00000649 8B1485[FD010000]            mov edx,dword[task_stacks_kernel+eax*4-4]
  1105 00000650 8915[04000000]              mov dword[tss_tt+0x04],edx
  1106 00000656 66C705[08000000]-           mov word[tss_tt+0x08],SEL_DATOS
  1107 0000065D [0000]             
  1108                                      
  1109 0000065F 8B0485[21020000]            mov eax,[task_contexts+eax*4-4]; puntero al nuevo almacenamiento de contextos.
  1110                                      
  1111                                      ;RECUPERO EL CONTEXTO DE LA TAREA NUEVA
  1112 00000666 8B4804                      mov ecx,[eax+4*1]
  1113 00000669 8B5008                      mov edx,[eax+4*2]
  1114 0000066C 8B580C                      mov ebx,[eax+4*3]
  1115 0000066F 8B6810                      mov ebp,[eax+4*4]
  1116 00000672 8B7014                      mov esi,[eax+4*5]
  1117 00000675 8B7818                      mov edi,[eax+4*6]
  1118 00000678 8B601C                      mov esp,[eax+4*7]
  1119 0000067B 8E5020                      mov ss,[eax+4*8+2*0]
  1120 0000067E 8E4022                      mov es,[eax+4*8+2*1]
  1121 00000681 8E5824                      mov ds,[eax+4*8+2*2]
  1122 00000684 8E6026                      mov fs,[eax+4*8+2*3]
  1123 00000687 8E6828                      mov gs,[eax+4*8+2*4]
  1124                                      
  1125 0000068A A1[A1060000]                mov eax,[.task_actual]
  1126                                      ;cargo el nuevo arbol de páginas
  1127 0000068F 8B0485[F1010000]            mov eax,[task_pds+eax*4-4]
  1128 00000696 0F22D8                      mov cr3, eax
  1129                                      
  1130                                      ;para este punto ya cargué la pila
  1131 00000699 FF30                        push dword[eax+4*0]; pusheo el valor del eax viejo!
  1132                                  
  1133 0000069B B020                        mov al, 0x20
  1134 0000069D E620                        out 0x20,al ; Marco el EOI
  1135                                      
  1136 0000069F 58                          pop eax; recupero el valor de eax!
  1137                                      
  1138 000006A0 CF                          iret; hago el ret para volver a la ejecución de la tarea correspondiente
  1139                                      
  1140 000006A1 00000000                    .task_actual dd 0x00
  1141                                      
  1142                                  handler_interr1: ;handler del teclado!
  1143 000006A5 60                          pushad; pusheo los registros de proposito general
  1144                                      
  1145 000006A6 E460                        in al, DATA_PORT_PS2 ;leo el valor de la tecla
  1146 000006A8 A2[CF000000]                mov [scan_code_actual],al ;guardo el scan_code en la variable correspondiente
  1147                                      
  1148 000006AD B020                        mov al, 0x20
  1149 000006AF E620                        out 0x20,al ; Marco el EOI
  1150                                      
  1151 000006B1 61                          popad
  1152                                      
  1153 000006B2 CF                          iret
  1154                                      
  1155                                  handler_interr2:
  1156 000006B3 CF                          iret
  1157                                      
  1158                                  handler_interr3:
  1159 000006B4 CF                          iret
  1160                                      
  1161                                  handler_interr4: ;Interrupcion de puerto serie (COM1)
  1162 000006B5 60                          pushad; pusheo los registros de proposito general
  1163                                  
  1164 000006B6 66BAFA03                    mov dx, 0x3F8+2;esta es la direccion del IIR para el COM1
  1165 000006BA EC                          in al,dx ;leo el valor del registro IIR (interrupt identifier register)
  1166 000006BB 88C3                        mov bl,al; paso al a bl
  1167                                      
  1168 000006BD 80E304                      and bl,0x04; veo a ver si el flag de Interrupcion por recepcion esta encendido
  1169 000006C0 80FB00                      cmp bl,0
  1170 000006C3 750C                        jne handler_interr4_rx
  1171                                      
  1172 000006C5 88C3                        mov bl,al;cargo nuevamente el valor original del IIR en bl!
  1173 000006C7 80E302                      and bl,0x02
  1174 000006CA 80FB00                      cmp bl,0
  1175 000006CD 7509                        jne handler_interr4_tx
  1176                                      
  1177 000006CF EB09                        jmp handler_interr4_fin
  1178                                      
  1179                                      handler_interr4_rx:
  1180 000006D1 A2[D4000000]                mov [buffer_COM1],al ;guardo lo recibido en la variable correspondiente
  1181 000006D6 EB02                        jmp handler_interr4_fin
  1182                                      
  1183                                      handler_interr4_tx:    
  1184 000006D8 EB00                        jmp handler_interr4_fin 
  1185                                      
  1186                                      handler_interr4_fin:
  1187 000006DA B020                        mov al, 0x20
  1188 000006DC E620                        out 0x20,al ; Marco el EOI
  1189                                  
  1190 000006DE 61                          popad
  1191                                      
  1192 000006DF CF                          iret
  1193                                      
  1194                                  handler_interr5:
  1195 000006E0 CF                          iret
  1196                                  
  1197                                  handler_interr6:
  1198 000006E1 CF                          iret
  1199                                      
  1200                                  handler_interr7:
  1201 000006E2 CF                          iret
  1202                                      
  1203                                  handler_interr8:
  1204 000006E3 CF                          iret
  1205                                      
  1206                                  handler_interr9:
  1207 000006E4 CF                          iret
  1208                                      
  1209                                  handler_interr10:
  1210 000006E5 CF                          iret
  1211                                      
  1212                                  handler_interr11:
  1213 000006E6 CF                          iret
  1214                                      
  1215                                  handler_interr12:
  1216 000006E7 CF                          iret
  1217                                      
  1218                                  handler_interr13:
  1219 000006E8 CF                          iret
  1220                                      
  1221                                  handler_interr14:
  1222 000006E9 CF                          iret
  1223                                      
  1224                                  handler_interr15:
  1225 000006EA CF                          iret
  1226                                  
  1227                                  sys_call:
  1228                                       
  1229 000006EB 83F801                       cmp eax, SYS_PRINT
  1230 000006EE 741B                         je .imprimir
  1231 000006F0 83F802                       cmp eax, SYS_CLRSCR
  1232 000006F3 7424                         je .limpiar_pant
  1233 000006F5 83F803                       cmp eax, SYS_GET_SCANCODE
  1234 000006F8 7432                         je .get_scancode
  1235 000006FA 83F804                       cmp eax, SYS_SET_SCANCODE
  1236 000006FD 7434                         je .set_scancode
  1237 000006FF 83F805                       cmp eax, SYS_ITOA
  1238 00000702 741C                         je ._itoa
  1239 00000704 83F806                       cmp eax, SYS_HLT
  1240 00000707 7432                         je ._hlt
  1241                                       
  1242 00000709 EB33                         jmp .fin
  1243                                      
  1244                                      .imprimir:
  1245 0000070B 53                              push ebx
  1246 0000070C 51                              push ecx 
  1247 0000070D 52                              push edx
  1248 0000070E 56                              push esi
  1249 0000070F E8ECF8FFFF                      call print
  1250 00000714 83C410                          add esp,16
  1251 00000717 EB25                            jmp .fin
  1252                                      
  1253                                      .limpiar_pant:
  1254 00000719 E816F9FFFF                      call clrscr
  1255 0000071E EB1E                            jmp .fin
  1256                                       
  1257                                       ._itoa:
  1258 00000720 53                              push ebx
  1259 00000721 51                              push ecx
  1260 00000722 E823F9FFFF                      call itoa
  1261 00000727 83C408                          add esp,8
  1262 0000072A EB12                            jmp .fin
  1263                                      
  1264                                          
  1265                                      .get_scancode:
  1266 0000072C A1[CF000000]                    mov eax,[scan_code_actual]
  1267 00000731 EB0B                            jmp .fin
  1268                                      
  1269                                      .set_scancode:
  1270 00000733 891D[CF000000]                 mov [scan_code_actual],ebx
  1271 00000739 EB03                           jmp .fin
  1272                                      
  1273                                      ._hlt:
  1274 0000073B F4                              hlt;
  1275 0000073C EB00                          jmp .fin
  1276                                  
  1277                                  .fin:
  1278 0000073E CF                          iret
  1279                                      
  1280                                  ;********************************************************************************
  1281                                  ; 						-  -- --- Fin de archivo --- --  -
  1282                                  ; D. Garcia 																c2013
  1283                                  ;********************************************************************************
  1284                                   

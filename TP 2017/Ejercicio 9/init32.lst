     1                                  ;################################################################################
     2                                  ;#	Título: Ejemplo basico de inicio desde BIOS									#
     3                                  ;#																				#
     4                                  ;#	Versión:		2.0							Fecha: 	22/08/2015				#
     5                                  ;#	Autor: 			D. Garcia					Tab: 	4						#
     6                                  ;#	Compilación:	Usar Makefile												#
     7                                  ;#	Uso: 			-															#
     8                                  ;#	------------------------------------------------------------------------	#
     9                                  ;#	Descripción:																#
    10                                  ;#		Inicializacion de un sistema basico desde BIOS							#
    11                                  ;#		Genera una BIOS ROM de 64kB para inicializacion y codigo principal		#
    12                                  ;#	------------------------------------------------------------------------	#
    13                                  ;#	Revisiones:																	#
    14                                  ;#		2.0 | 22/08/2015 | D.GARCIA | Inicio desde BIOS. Cambio de VMA			#
    15                                  ;#		1.0 | 04/03/2013 | D.GARCIA | Inicial									#
    16                                  ;#	------------------------------------------------------------------------	#
    17                                  ;#	TODO:																		#
    18                                  ;#		-																		#
    19                                  ;################################################################################
    20                                  
    21                                  ;********************************************************************************
    22                                  ; Definicion de la base y el largo de la pila
    23                                  ;********************************************************************************
    24                                  %define STACK_ADDRESS 0x00140000     
    25                                  %define STACK_SIZE_SO 1023
    26                                  %define STACK_SIZE_TAREAS 1023
    27                                  
    28                                  
    29                                  ;Definiciones para configurar el PIC 8259
    30                                  %define PIC1		0x20		 
    31                                  %define PIC2		0xA0	 
    32                                  %define PIC1_COMMAND	PIC1
    33                                  %define PIC1_DATA	(PIC1+1)
    34                                  %define PIC2_COMMAND	PIC2
    35                                  %define PIC2_DATA	(PIC2+1)
    36                                  
    37                                  %define ICW1_PIC1 00010001b 
    38                                  ;bits 7:5='000' siempre en x86
    39                                  ;bit 4='1' bit de inicializacion
    40                                  ;bit 3='0' si es '0' dispara por flanco, si es '1' dispara por nivel
    41                                  ;bit 2='0' se ignora en x86 y por defecto es '0'
    42                                  ;bit 1='0' si es '1' indica que hay un solo PIC, si es '0' indica que se colocara el pic en casacada con otro.
    43                                  ;bit 0='1' si es '1' indica que le mandaremos la ICW4, lo cual en este caso queremos hacer
    44                                  %define ICW1_PIC2 ICW1_PIC1
    45                                  ;Misma ICW1
    46                                  
    47                                  %define ICW2_PIC1 0x20
    48                                  ;La ICW2 contiene la base donde comenzara a buscar los handlers es decir Para IRQ0 -> IDT[0x20], para IRQ1->IDT[0x21], etc
    49                                  %define ICW2_PIC2 0x28
    50                                  ;Lo mismo que el anterior, coloco las 8 Interrupciones del segundo pic contiguas en el vector a a las anteriores
    51                                  
    52                                  %define ICW3_PIC1 00000100b
    53                                  ;Cada bit hace referencia a un pin de interupcion. Debo encender el bit que represente la linea de interrupcion a la que esta conectada el PIC2  esclavo, en este caso como esta conectado a la IRQ2, enciendoel bit 2.
    54                                  
    55                                  %define ICW3_PIC2 00000010b
    56                                  ;En el caso del PIC2 los bits 7:3 van en 0, y los bits 2:0 indican en codigo binario a que linea del maestro se encuentra conectado el esclavo (En este caso IRQ2)
    57                                  
    58                                  %define ICW4_PIC1 00000001b
    59                                  ;Lo unico que usamos de aqui es el bit 0, que debe estar en '1' para el caso de uPs 80x86
    60                                  
    61                                  %define ICW4_PIC2 ICW4_PIC1
    62                                  
    63                                  %define IMR_PIC1 PIC1_DATA
    64                                  %define IMR_PIC2 PIC2_DATA
    65                                  ;Interrupt mask register para cada PIC
    66                                  
    67                                  %define EOI_COMMAND 0x20
    68                                  ;Comando para indcar que finaliza la interrupcion
    69                                  
    70                                  %define MASK_PIC1 0xFC
    71                                  ;Habilito las interrupciones 0 y 1!!
    72                                  %define MASK_PIC2 0xFF
    73                                  ;Enmascaro todas las interrupciones
    74                                  
    75                                  
    76                                  %define COM1 0x3F8 
    77                                  ;Direccion del puerto serie COM1
    78                                  
    79                                  %define LENGTH_VECT_HANDLERS_EXCEP 32
    80                                  %define LENGTH_VECT_HANDLERS_INTERR 16
    81                                  %define LENGTH_HASTA_INT80h 0x80-LENGTH_VECT_HANDLERS_EXCEP-LENGTH_VECT_HANDLERS_INTERR
    82                                  
    83                                  
    84                                  %define LONG_TSS 104
    85                                  
    86                                  ;********************************************************************************
    87                                  ; Simbolos externos y globales
    88                                  ;********************************************************************************
    89                                  GLOBAL 		Entry
    90                                  
    91                                  GLOBAL          IDT32
    92                                  
    93                                  GLOBAL          PAGE_DIR_SO
    94                                  GLOBAL          PAGE_TABLES1_40_SO
    95                                  
    96                                  GLOBAL          PAGE_DIR_TASK1
    97                                  GLOBAL          PAGE_DIR_TASK2
    98                                  GLOBAL          PAGE_DIR_TASK3
    99                                  
   100                                  GLOBAL          task1_context
   101                                  GLOBAL          task2_context
   102                                  GLOBAL          task3_context
   103                                  
   104                                  GLOBAL          task1_SIMD
   105                                  GLOBAL          task2_SIMD
   106                                  GLOBAL          task3_SIMD
   107                                  
   108                                  GLOBAL          SEL_CODIGO
   109                                  GLOBAL          SEL_CODIGO_NP3
   110                                  GLOBAL          SEL_DATOS
   111                                  GLOBAL          SEL_DATOS_NP3
   112                                  
   113                                  GLOBAL          tss_tt
   114                                  
   115                                  EXTERN		start32
   116                                  EXTERN          kernel_idle
   117                                  
   118                                  EXTERN          sys_call
   119                                  EXTERN          vect_handlers
   120                                  
   121                                  EXTERN          __sys_tables_LMA
   122                                  EXTERN          __sys_tables_start
   123                                  EXTERN          __sys_tables_end
   124                                  EXTERN          __sys_tables_size
   125                                  EXTERN          __sys_tables_phy_addr
   126                                  
   127                                  EXTERN          __main_LMA
   128                                  EXTERN          __main_start
   129                                  EXTERN          __main_end
   130                                  EXTERN          __main_size
   131                                  EXTERN          __main_phy_addr
   132                                  
   133                                  EXTERN          __mdata_LMA
   134                                  EXTERN          __mdata_start
   135                                  EXTERN          __mdata_end
   136                                  EXTERN          __mdata_size
   137                                  EXTERN          __mdata_phy_addr
   138                                  
   139                                  EXTERN          __pag_tables_LMA
   140                                  EXTERN          __pag_tables_start
   141                                  EXTERN          __pag_tables_end
   142                                  EXTERN          __pag_tables_size
   143                                  
   144                                  
   145                                  EXTERN          __func_LMA
   146                                  EXTERN          __func_start
   147                                  EXTERN          __func_end
   148                                  EXTERN          __func_size
   149                                  EXTERN          __func_phy_addr
   150                                  
   151                                  EXTERN          __stack_so_start
   152                                  EXTERN          __stack_so_end
   153                                  EXTERN          __stack_so_size
   154                                  EXTERN          __stack_so_phy_addr
   155                                  
   156                                  EXTERN          __bss_start
   157                                  EXTERN          __bss_end
   158                                  EXTERN          __bss_size
   159                                  EXTERN          __bss_phy_addr
   160                                  
   161                                  ;EXTERNS PARA EL CODIGO DE LAS TAREAS
   162                                  EXTERN          __task1_code_LMA
   163                                  EXTERN          __task1_code_start
   164                                  EXTERN          __task1_code_end
   165                                  EXTERN          __task1_code_size
   166                                  EXTERN          __task1_code_phy_addr
   167                                  
   168                                  EXTERN          __task2_code_LMA
   169                                  EXTERN          __task2_code_start
   170                                  EXTERN          __task2_code_end
   171                                  EXTERN          __task2_code_size
   172                                  EXTERN          __task2_code_phy_addr
   173                                  
   174                                  EXTERN          __task3_code_LMA
   175                                  EXTERN          __task3_code_start
   176                                  EXTERN          __task3_code_end
   177                                  EXTERN          __task3_code_size
   178                                  EXTERN          __task3_code_phy_addr
   179                                  
   180                                  ;EXTERNS PARA LAS PILAS DE LAS TAREAS
   181                                  EXTERN          __task1_stack_start 
   182                                  EXTERN          __task1_stack_end 
   183                                  EXTERN          __task1_stack_size	
   184                                  EXTERN          __task1_stack_phy_addr
   185                                  
   186                                  EXTERN          __task2_stack_start 
   187                                  EXTERN          __task2_stack_end 
   188                                  EXTERN          __task2_stack_size	
   189                                  EXTERN          __task2_stack_phy_addr
   190                                  
   191                                  EXTERN          __task3_stack_start 
   192                                  EXTERN          __task3_stack_end 
   193                                  EXTERN          __task3_stack_size	
   194                                  EXTERN          __task3_stack_phy_addr
   195                                  
   196                                  EXTERN          __task1_stack_NP3_start 
   197                                  EXTERN          __task1_stack_NP3_end 
   198                                  EXTERN          __task1_stack_NP3_size	
   199                                  EXTERN          __task1_stack_NP3_phy_addr
   200                                  
   201                                  EXTERN          __task2_stack_NP3_start 
   202                                  EXTERN          __task2_stack_NP3_end 
   203                                  EXTERN          __task2_stack_NP3_size	
   204                                  EXTERN          __task2_stack_NP3_phy_addr
   205                                  
   206                                  
   207                                  ;********************************************************************************
   208                                  ; Seccion de codigo de inicializacion
   209                                  ;********************************************************************************
   210                                  USE16
   211                                  SECTION 	.reset_vector					; Reset vector del procesador
   212                                  
   213                                  Entry:										; Punto de entrada definido en el linker
   214 00000000 66E9(00000000)          	jmp 	dword start						; Punto de entrada de mi BIOS
   215 00000006 00<rept>                	times   16-($-Entry) db 0				; Relleno hasta el final de la ROM
   216                                  
   217                                  ;********************************************************************************
   218                                  ; Seccion de codigo de inicializacion
   219                                  ;********************************************************************************
   220                                  USE32
   221                                  SECTION 	.init
   222                                  
   223                                  ;--------------------------------------------------------------------------------
   224                                  ; Punto de entrada
   225                                  ;--------------------------------------------------------------------------------
   226                                  start:									; Punto de entrada
   227 00000000 <incbin>                	INCBIN "init16.bin"					; Binario de 16 bits
   228                                  
   229                                  ;Saltar a Init32
   230                                   
   231                                   
   232                                  ;;CODIGO AGREGADO POR GONZALO
   233                                      
   234                                  ;Movimiento del codigo correspondiente a las tablas de sistema usando los datos del linker script, lo debo hacer sin llamadas ya que no puedo usar el stack pointer hasta tanto no inicialice las estructuras!   
   235                                  
   236 000013C2 BE[00000000]                mov esi, __sys_tables_LMA
   237 000013C7 BF[00000000]                mov edi, __sys_tables_phy_addr ;Muevo las tablas a su DIRECCION FISICA FINAL!!!!
   238 000013CC B9[00000000]                mov ecx, __sys_tables_size
   239 000013D1 F3A4                        rep movsb 
   240                                   
   241                                      
   242                                  ;Cargo la GDT DE MANERA PROVISORIA, ya que la tengo en memoria fisica, la tengo que cargar con la direccion de base de memoria fisica hasta habilitar la paginacion
   243 000013D3 B8[30000000]                mov eax,my_gdtr; muevo la parte del "Tamaño" a bx.
   244 000013D8 2D[00000000]                sub eax,__sys_tables_start ; le resto la direccion LINEAL de inicio (conozco su ofset dentro de la seccion)
   245 000013DD 05[00000000]                add eax,__sys_tables_phy_addr; le sumo la direccion FISICA a la cual copie la ENTRADA DEL REGISTRO DE TABLA. De esta forma conozco la direccion final en ram.
   246                                      ;En eax ya tengo la direccion donde esta ubicada my_gdtr en RAM, el problema es que la parte del gdtr copiado tiene aún la direccion base LINEAL original (erronea). Debo entonces modificar esa direccion base y 
   247 000013E2 8D5802                      lea ebx,[eax+2]; cargo la direccion en la que se encuentra el campo de base.
   248 000013E5 C703[00000000]              mov dword[ebx],__sys_tables_phy_addr; cargo en esa posicion la DIRECCION FISICA.
   249 000013EB 0F0110                      lgdt [eax]
   250                                  
   251                                  ;Inicializacion de la pila para poder llamar funciones!!
   252 000013EE 66B81000                    mov ax,SEL_DATOS
   253 000013F2 8ED0                        mov ss,ax
   254 000013F4 B8[00000000]                mov eax,__stack_so_phy_addr
   255 000013F9 05[00000000]                add eax,__stack_so_size
   256 000013FE 89C4                        mov esp,eax ;(direccion fisica de la pila + tamaño, ojo no pisar otras secciones!!)    
   257                                      
   258                                  ;Movimiento del resto del codigo a los lugares que corresponda! los parametros los pasa el Linker Script       
   259 00001400 68[00000000]                push __main_size
   260 00001405 68[00000000]                push __main_LMA
   261 0000140A 68[00000000]                push __main_phy_addr
   262 0000140F E823040000                  call my_memcpy
   263 00001414 83C40C                      add esp,3*4
   264                                      
   265 00001417 68[00000000]                push __func_size
   266 0000141C 68[00000000]                push __func_LMA
   267 00001421 68[00000000]                push __func_phy_addr
   268 00001426 E80C040000                  call my_memcpy
   269 0000142B 83C40C                      add esp,3*4
   270                                      
   271 0000142E 68[00000000]                push __mdata_size
   272 00001433 68[00000000]                push __mdata_LMA
   273 00001438 68[00000000]                push __mdata_phy_addr
   274 0000143D E8F5030000                  call my_memcpy
   275 00001442 83C40C                      add esp,3*4
   276                                      
   277                                  ;Movimiento del código de las tareas a los lugares correspondientes.
   278 00001445 68[00000000]                push __task1_code_size
   279 0000144A 68[00000000]                push __task1_code_LMA
   280 0000144F 68[00000000]                push __task1_code_phy_addr
   281 00001454 E8DE030000                  call my_memcpy
   282 00001459 83C40C                      add esp,3*4
   283                                      
   284 0000145C 68[00000000]                push __task2_code_size
   285 00001461 68[00000000]                push __task2_code_LMA
   286 00001466 68[00000000]                push __task2_code_phy_addr
   287 0000146B E8C7030000                  call my_memcpy
   288 00001470 83C40C                      add esp,3*4
   289                                      
   290 00001473 68[00000000]                push __task3_code_size
   291 00001478 68[00000000]                push __task3_code_LMA
   292 0000147D 68[00000000]                push __task3_code_phy_addr
   293 00001482 E8B0030000                  call my_memcpy
   294 00001487 83C40C                      add esp,3*4
   295                                      
   296                                  ;Inicializo en cero las zonas de memoria dinamica    
   297 0000148A 31C0                        xor eax,eax ;limpio el registro eax para que quede en cero
   298 0000148C BF[00000000]                mov edi, __bss_phy_addr
   299 00001491 B9[00000000]                mov ecx, __bss_size
   300 00001496 F3AA                        rep stosb ;lleno toda la region de memoria correspondiente a variables no inicializadas con ceros
   301                                      
   302                                  
   303                                      ;Inicializo las tablas de PAGINACION!!
   304 00001498 E8F4010000                  call InitTagPag
   305                                  
   306 0000149D 0F20C0                      mov eax,CR0; cargo CR0 en eax
   307 000014A0 0D00000080                  or eax, 0x80000000; enciendo el bit 31, habilito paginacion!
   308 000014A5 0F22C0                      mov CR0,eax
   309                                      
   310                                      
   311                                  ;Una vez habilitada la paginacion, el procesador va a buscar my_gdtr y la va a traducir de memoria lineal a fisica... pero como en fisica tengo cargado
   312                                  ;El valor de gdtr fisico, y debo en realidad guardar el lineal en el registro... entonces lo debo editar!.
   313 000014A8 C705[32000000]-             mov dword[my_gdtr+2],__sys_tables_start; cargo la base con la direccion lineal!!
   314 000014AE [00000000]         
   315 000014B2 0F0115[30000000]            lgdt[my_gdtr]; cargo el registro GDTR
   316                                      
   317                                  ;Tambien debo recargar la pila!! ahora ya con las direcciones LINEALES
   318 000014B9 66B81000                    mov ax,SEL_DATOS
   319 000014BD 8ED0                        mov ss,ax
   320 000014BF BC[00000000]                mov esp,__stack_so_end
   321                                      
   322                                  ;Carga de la IDT. LA DEBO CARGAR DESPUES DE LAS TABLAS DE PAGINAS YA QUE DISPONGO DE LAS DIRECCIONES LINEALES DE LOS HANDLERS por el linker script.
   323 000014C4 E85D000000                  call InitIDT
   324                                  ;Carga de las tablas de sistema
   325 000014C9 0F011D[36000000]            lidt [my_idtr]
   326                                  
   327                                  ;Inicializo la TSS    
   328 000014D0 E806010000                  call InitTSS
   329 000014D5 0F0115[30000000]            lgdt [my_gdtr] ;recargo el registro!!
   330                                      
   331 000014DC C705[04000000]-             mov dword[tss_tt+0x04],__stack_so_end
   332 000014E2 [00000000]         
   333 000014E6 66C705[08000000]10-         mov word[tss_tt+0x08],SEL_DATOS
   334 000014EE 00                 
   335 000014EF 66B82800                    mov ax,SEL_TSS
   336 000014F3 0F00D8                      ltr ax
   337                                      
   338                                  ;Inicializacion de los PICs
   339 000014F6 E84C030000                  call InitPIC; llamada a la rutina de inicializacion de los PICS
   340                                  
   341                                  ;Inicializacion del PIT
   342 000014FB E870030000                  call InitPIT
   343                                  
   344                                  ;Inicializacion del puerto serie
   345 00001500 E87A030000                  call InitCOM1
   346                                      
   347                                  ;Habilitacion de las interrupciones    
   348 00001505 FB                          sti
   349                                  
   350                                  ;Habilitacion de los bits necesarios para usar SIMD
   351 00001506 0F20C0                      mov eax,cr0
   352 00001509 BB0C000000                  mov ebx,0x0C
   353 0000150E F7D3                        not ebx;
   354 00001510 21D8                        and eax,ebx; Pongo en 0 los bits 2 y 3, es decir EM y TS para operar en SIMD
   355 00001512 0F22C0                      mov cr0,eax;actualizo el cr0
   356                                      
   357 00001515 0F20E0                      mov eax,cr4
   358 00001518 0D00020000                  or eax,0x200; se setea el bit 9!, soporte para fxsave y fxrstor
   359                                  
   360                                  ;Salto a la primera tarea.
   361                                      
   362 0000151D B8[00000000]                mov eax,kernel_idle ;coloco en eax el offset del start
   363 00001522 6A08                        push dword SEL_CODIGO ; Pusheo primero el selector de codigo
   364 00001524 50                          push eax ;luego el offset
   365 00001525 CB                          retf ;si hago un return far saltare a SEL_CODIGO:start32 que es en el archivo "main"
   366                                  
   367                                  
   368                                  ;;CODIGO AGREGADO POR GONZALO
   369                                  
   370                                  
   371                                  
   372                                  
   373                                  
   374                                  
   375                                  ;--------------------------------------------------------------------------------
   376                                  ; Inicializacion de la idt
   377                                  ;--------------------------------------------------------------------------------
   378                                  InitIDT:
   379 00001526 B900000000                  mov ecx,0
   380 0000152B BB20000000                  mov ebx, LENGTH_VECT_HANDLERS_EXCEP ; cargo del vector de handlers de excepciones en ebx   
   381 00001530 0F84A4000000                je fin_carga_idt
   382                                  
   383                                      
   384                                  ;carga de la parte de excepciones de la IDT
   385                                  ciclo_carga_idt_excep:
   386 00001536 8B048D[00000000]            mov eax, [vect_handlers+4*ecx] ;cada handler es una etiqueta, estan espaciadas 4bytes en el vector
   387 0000153D 668904CD[00000000]          mov [IDT32+8*ecx], ax
   388 00001545 66C704CD[02000000]-         mov word[IDT32+8*ecx+2], SEL_CODIGO
   389 0000154D 0800               
   390 0000154F C604CD[04000000]00          mov byte[IDT32+8*ecx+4],0x00
   391 00001557 C604CD[05000000]8E          mov byte[IDT32+8*ecx+5],0x8E;
   392 0000155F C1E810                      shr eax, 16 ; debo borrar los primeros 16 bits, asi me quedo con la parte alta
   393 00001562 668904CD[06000000]          mov[IDT32+8*ecx+6],ax
   394 0000156A 41                          inc ecx
   395 0000156B 39D9                        cmp ecx,ebx ;carga hasta el descriptor CANT_HANDLERS-1!
   396 0000156D 75C7                        jne ciclo_carga_idt_excep
   397                                  
   398 0000156F BA10000000                  mov edx, LENGTH_VECT_HANDLERS_INTERR; cargo la cantidad de handlers de interrupciones en edx
   399 00001574 01D3                        add ebx,edx; le sumo a ebx, edx. Con esto tendre el total de handlers de interrupciones y excepciones y se hasta donde tengo que llenar la IDT 
   400                                  
   401                                  ciclo_carga_idt_interr:
   402 00001576 8B048D[00000000]             mov eax, [vect_handlers+4*ecx] ;cada handler es una etiqueta, estan espaciadas 4bytes en el vector
   403 0000157D 668904CD[00000000]           mov [IDT32+8*ecx], ax
   404 00001585 66C704CD[02000000]-          mov word[IDT32+8*ecx+2], SEL_CODIGO
   405 0000158D 0800               
   406 0000158F C604CD[04000000]00           mov byte[IDT32+8*ecx+4],0x00
   407 00001597 C604CD[05000000]8E           mov byte[IDT32+8*ecx+5],0x8E;
   408 0000159F C1E810                       shr eax, 16 ; debo borrar los primeros 16 bits, asi me quedo con la parte alta
   409 000015A2 668904CD[06000000]           mov[IDT32+8*ecx+6],ax
   410 000015AA 41                           inc ecx
   411 000015AB 39D9                         cmp ecx,ebx ;carga hasta el descriptor CANT_HANDLERS-1!
   412 000015AD 75C7                         jne ciclo_carga_idt_interr    
   413                                  
   414                                  carga_int_80h:
   415 000015AF B8[00000000]                mov eax,sys_call
   416 000015B4 66A3[00040000]              mov [IDT_INT80h],ax
   417 000015BA 66C705[02040000]08-         mov word[IDT_INT80h+2], SEL_CODIGO
   418 000015C2 00                 
   419 000015C3 C605[04040000]00            mov byte[IDT_INT80h+4],0x00
   420 000015CA C605[05040000]EE            mov byte[IDT_INT80h+5],0xEE; DPL=3!!! fundamental!
   421 000015D1 C1E810                      shr eax,16
   422 000015D4 66A3[06040000]              mov [IDT_INT80h+6],ax
   423                                  
   424                                       
   425                                  fin_carga_idt:
   426 000015DA C3                          ret
   427                                  
   428                                      
   429                                  ;--------------------------------------------------------------------------------
   430                                  ; Inicializacion de la TSS
   431                                  ;--------------------------------------------------------------------------------    
   432                                  InitTSS:
   433 000015DB B8[00000000]            mov eax,tss_tt
   434                                  
   435 000015E0 66A3[2A000000]          mov word[GDT32+SEL_TSS+2],ax ; 16 LSb de la base. en ax.
   436 000015E6 C1E810                  shr eax,16; hago un shift right de 16 posiciones para quedarme en ax con los 16 MSb
   437 000015E9 A2[2C000000]            mov byte[GDT32+SEL_TSS+4],al
   438 000015EE 8825[2F000000]          mov byte[GDT32+SEL_TSS+7],ah
   439                                  
   440 000015F4 C3                      ret
   441                                  
   442                                  ;--------------------------------------------------------------------------------
   443                                  ; Inicializacion de las tablas de paginacion!
   444                                  ;--------------------------------------------------------------------------------
   445                                  InitTabPag_kernel:
   446                                   ;Busco hacer identity mapping, direcciones lineales se corresponden con las fisicas, ahora uso paginas de 4k
   447                                   ;Debo mapear las paginas de la rom y el Vector de reset es decir desde 0xFFFF0000 a 0xFFFF FFFF (es decir los ultimos 64k = 16 paginas) de la ultima entrada del directorio!.
   448                                   
   449                                   ;La base de la tabla correspondiente a esta entrada del directorio es PAGE_TABLE1024, por lo tanto, los bits 31 a 12, deberan contener los primeros 20 bits de esta etiqueta.
   450 000015F5 B8[00900200]             mov eax, PAGE_TABLE1023_SO; como es una entrada de tabla de paginas, se suponen que los primeros 12 bits estan en cero!
   451 000015FA 83C803                   or eax, 0x03; para que sea pagina presente y de lectura ecareyscritura
   452 000015FD A3[FC0F0000]             mov dword[PAGE_DIR_SO+1023*4],eax 
   453                                   
   454                                   
   455                                  ;Tambien debo mapear la memoria de video 0x000B 8000 y  de 0x0010 0000 a 0x0015 0000 todo esto corresponde a la primera entrada del directorio! que si hago identity mapping    ;abarcaria desde la direccion 0x0000 00
   456 00001602 B8[00100000]            mov eax, PAGE_TABLE0_SO
   457 00001607 83C803                  or eax,0x03
   458 0000160A A3[00000000]            mov dword[PAGE_DIR_SO],eax ;  bit 0= 1 (presente), bit 1='1' (R/W) bit 7='1' (paginas grandes!!). Los bits 31 a 22 van en 0, ya que voy a mapear con identity mapping los primeros 4mb!!!
   459                                  
   460                                  
   461                                  ;Inicializacion de las tablas de paginas.
   462                                  
   463                                  ;Paginas page table 1: 0x0000 0000 a 0x0000 1000 (fisicas) entrada 1, no presente
   464                                  ;                      0x0000 1000 a 0x000B 8000 (fisicas) entradas 2 a 184 inclusive, no presentes
   465                                  ;                      0x0000 B800 a 0x000B 9000 (fisicas) entrada 185, presente! memoria de video.
   466                                  ;                      0x0000 B900 a 0x0010 0000 (fisicas) entrada 186 a 256 no presentes!
   467                                  ;                      0x0010 0000 a 0x0015 0000 (fisicas) entradas 257 a 336 presentes para el codigo.
   468                                  ;                      0x0015 0000 a 0x0040 0000 (fisicas) entradas entradas 337 a 1024 no presentes
   469 0000160F B800800B00              mov eax, 0xB8000; cargo eax con la direccion de video.
   470 00001614 C1E80C                  shr eax, 12; shifteo 12 bits, que es lo mismo que dividir por 4096, esto me da 0xB8=184!
   471 00001617 C70485[00100000]03-     mov dword[PAGE_TABLE0_SO+eax*4],0x000B8003; apunta la direccion fisica B8000!! la base de la pagina!!
   472 0000161F 800B00             
   473                                  
   474                                  
   475 00001622 B800000000              mov eax, 0x00000 ; a partir de cuando necesito paginas.
   476 00001627 83C803                  or eax, 0x03; prendo los ultimos 3 bits que van a quedar siempre encendidos por la configuracion de la pagina
   477                                  
   478                                  ciclo_InitPAG0_IM: ; en esta parte cargo las primeras 0x100000 direcciones que van con identity mapping para las tablas de paginas, memoria de video, etc
   479 0000162A 89C3                        mov ebx,eax;
   480 0000162C C1EB0C                      shr ebx, 12; shifteo 12 bits, es decir divido por 0x1000 = 4096
   481 0000162F 89049D[00100000]            mov dword[PAGE_TABLE0_SO+ebx*4],eax; cargo la entrada
   482 00001636 0500100000                  add eax, 0x1000; le sumo a eax 0x1000 es decir, empezara en 0x100003 luego 0x101003 y asi... hasta la ultima pagina que terminara en 0x150000 
   483 0000163B 3D00001000                  cmp eax, 0x100000; hasta esta direccion hago identity mapping
   484 00001640 72E8                        jb ciclo_InitPAG0_IM; me voy si ya cargue todas las paginas!.
   485                                      
   486                                  ciclo_InitPAG0_NIM: ;en esta parte cargo lo que NO ES identy mapping. Es decir desde la 0x100000 hasta la 0x400000 (todo el resto de la primera pagina)
   487 00001642 89C3                        mov ebx,eax;
   488 00001644 89C2                        mov edx,eax;
   489 00001646 81C200001000                add edx,0x100000; le sumo 0x100000 que es la diferencia entre las direcciones LINEALES y las FISICAS (Fisicas = Lineales + 0x100000 en este caso, por enunciado)
   490 0000164C C1EB0C                      shr ebx, 12; shifteo 12 bits, es decir divido por 0x1000 = 4096
   491 0000164F 89149D[00100000]            mov dword[PAGE_TABLE0_SO+ebx*4],edx; cargo la entrada
   492 00001656 0500100000                  add eax, 0x1000; le sumo a eax 0x1000 es decir, empezara en 0x100003 luego 0x101003 y asi... hasta la ultima pagina que terminara en 0x150000 
   493 0000165B 3D00004000                  cmp eax, 0x400000; hasta esta direccion hago identity mapping. 0x400000 FISICA que es donde empiezan las nuevas paginas 
   494 00001660 72E0                        jb ciclo_InitPAG0_NIM; me voy si ya cargue todas las paginas!.
   495                                      
   496                                  
   497 00001662 B80000FFFF              mov eax, 0xFFFF0000; a partir de esta direccion y hasta 0xFFFF FFFF quiero paginar, es decir 64k= 16 paginas     
   498 00001667 83C803                  or eax, 0x03
   499                                  
   500                                  ciclo_InitPAG1023:
   501 0000166A 89C3                        mov ebx,eax;
   502 0000166C 81EB0000C0FF                sub ebx, 1024*1023*4096; como es identity mapping la ultima entrada del directorio direccionara desde 1024*1023*4096 hasta 1024*1024*4096 o lo que es lo mismo decir, desde 0xFFC0 0000 a 0xFFFF FFFF. Le resto ent
   503 00001672 C1EB0C                      shr ebx, 12; shifteo 12 bits, es decir divido por 0x1000 = 4096 para conocer finalmente el indice dentro de la tabla!
   504 00001675 89049D[00900200]            mov dword[PAGE_TABLE1023_SO+ebx*4],eax; cargo la entrada
   505 0000167C 0500100000                  add eax, 0x1000; le sumo a eax 0x1000 es decir, empezara en 0x100003 luego 0x101003 y asi... hasta la ultima pagina que terminara en 0x150000 
   506 00001681 3D03F0FFFF                  cmp eax, 0xFFFFF003;
   507 00001686 75E2                        jne ciclo_InitPAG1023; me voy si ya cargue todas las paginas!.
   508                                  
   509                                      
   510                                  fin_InitPAG:
   511 00001688 B8[00000000]            mov eax, PAGE_DIR_SO; cargo en eax la base del directorio de paginas
   512 0000168D 0F22D8                  mov CR3, eax; cargo CR3 con la base del directorio de paginas!!
   513                                  
   514 00001690 C3                      ret
   515                                  
   516                                  
   517                                  
   518                                  ;--------------------------------------------------------------------------------
   519                                  ; Inicializacion de las tablas de paginacion de las TAREAS!
   520                                  ;--------------------------------------------------------------------------------
   521                                  InitTagPag:
   522                                  
   523 00001691 E85FFFFFFF              call InitTabPag_kernel ;Inicializo las tablas de paginas del kernel
   524                                  
   525                                  
   526 00001696 B800000000                  mov eax,0
   527 0000169B B900040000                  mov ecx, 1024
   528                                  .loop_clean:
   529                                      ;Limpio los directorios de páginas para dejar todas las entradas "no presentes". Luego pondré presentes solo las que usaré.
   530 000016A0 89048D[FC9F0200]            mov [PAGE_DIR_TASK1+ecx*4-4],eax
   531 000016A7 89048D[FCAF0200]            mov [PAGE_DIR_TASK2+ecx*4-4],eax
   532 000016AE 89048D[FCBF0200]            mov [PAGE_DIR_TASK3+ecx*4-4],eax
   533                                      
   534                                      ;Copio la tabla de paginas 0 del kernel a las de las tareas para tener las traducciones handlers, las tablas de paginas,etc. 
   535 000016B5 8B1C8D[FC0F0000]            mov ebx,[PAGE_TABLE0_SO+ecx*4-4]
   536 000016BC 891C8D[FCCF0200]            mov [PAGE_TABLE0_TASK1+ecx*4-4],ebx
   537 000016C3 891C8D[FCDF0200]            mov [PAGE_TABLE0_TASK2+ecx*4-4],ebx
   538 000016CA 891C8D[FCEF0200]            mov [PAGE_TABLE0_TASK3+ecx*4-4],ebx
   539                                      
   540                                      ;Las tablas de páginas número "5" también las pongo todas en cero, luego pondré presentes solo las que se usan.
   541 000016D1 89048D[FCFF0200]            mov [PAGE_TABLE6_TASK1+ecx*4-4],eax
   542 000016D8 89048D[FC0F0300]            mov [PAGE_TABLE6_TASK2+ecx*4-4],eax
   543 000016DF 89048D[FC1F0300]            mov [PAGE_TABLE6_TASK3+ecx*4-4],eax
   544 000016E6 E2B8                    loop .loop_clean
   545                                  
   546                                  ;Carga de los directorios de páginas
   547 000016E8 B8[00D00200]                mov eax,PAGE_TABLE0_TASK1;
   548 000016ED 83C807                      or eax,0x07; Usuario, presente y lectura escritura
   549 000016F0 A3[00A00200]                mov [PAGE_DIR_TASK1+4*0],eax
   550 000016F5 B8[00000300]                mov eax, PAGE_TABLE6_TASK1;
   551 000016FA 83C807                      or eax, 0x07; usuario, presente y lectura escritura
   552 000016FD A3[18A00200]                mov [PAGE_DIR_TASK1+4*6],eax
   553                                      
   554 00001702 B8[00E00200]                mov eax,PAGE_TABLE0_TASK2;
   555 00001707 83C807                      or eax,0x07; presente y lectura escritura
   556 0000170A A3[00B00200]                mov [PAGE_DIR_TASK2+4*0],eax
   557 0000170F B8[00100300]                mov eax, PAGE_TABLE6_TASK2;
   558 00001714 83C807                      or eax, 0x07;
   559 00001717 A3[18B00200]                mov [PAGE_DIR_TASK2+4*6],eax
   560                                      
   561 0000171C B8[00F00200]                mov eax,PAGE_TABLE0_TASK3;
   562 00001721 83C803                      or eax,0x03; presente y lectura escritura
   563 00001724 A3[00C00200]                mov [PAGE_DIR_TASK3+4*0],eax
   564 00001729 B8[00200300]                mov eax, PAGE_TABLE6_TASK3;
   565 0000172E 83C803                      or eax, 0x03;
   566 00001731 A3[18C00200]                mov [PAGE_DIR_TASK3+4*6],eax
   567                                  
   568                                  ;Carga de las tablas de páginas 
   569                                  ;TAREA 1   
   570 00001736 B8[00000000]               mov eax, __task1_stack_start
   571 0000173B BB00004000                 mov ebx, 0x400000
   572 00001740 31D2                       xor edx,edx; limpio edx
   573 00001742 F7F3                       div ebx; en eax queda el resultado de la division de eax/ebx y en edx queda el resto!
   574 00001744 C1EA0C                     shr edx,12; ahora ne edx me queda la posición dentro de la tabla de páginas.
   575 00001747 B8[00000000]               mov eax, __task1_stack_phy_addr
   576 0000174C 83C803                     or eax,0x03 ;usuario,presente y lectoescritura
   577 0000174F 890495[00D00200]           mov [PAGE_TABLE0_TASK1+edx*4],eax;
   578                                     
   579 00001756 B8[00000000]               mov eax, __task1_stack_NP3_start
   580 0000175B BB00004000                 mov ebx, 0x400000
   581 00001760 31D2                       xor edx,edx
   582 00001762 F7F3                       div ebx
   583 00001764 C1EA0C                     shr edx,12
   584 00001767 B8[00000000]               mov eax, __task1_stack_NP3_phy_addr
   585 0000176C 83C807                     or eax, 0x07
   586 0000176F 890495[00D00200]           mov [PAGE_TABLE0_TASK1+edx*4],eax
   587                                     
   588 00001776 B8[00000000]               mov eax, __task1_code_start
   589 0000177B BB00004000                 mov ebx, 0x400000
   590 00001780 31D2                       xor edx,edx; limpio edx
   591 00001782 F7F3                       div ebx; en eax queda el resultado de la division de eax/ebx y en edx queda el resto!
   592 00001784 C1EA0C                     shr edx,12; ahora ne edx me queda la posición dentro de la tabla de páginas.
   593 00001787 B8[00000000]               mov eax, __task1_code_phy_addr
   594 0000178C 83C807                     or eax,0x07 ;presente y lectoescritura
   595 0000178F 890495[00000300]           mov [PAGE_TABLE6_TASK1+edx*4],eax;
   596                                     
   597                                  ;TAREA 2
   598 00001796 B8[00000000]               mov eax, __task2_stack_start
   599 0000179B BB00004000                 mov ebx, 0x400000
   600 000017A0 31D2                       xor edx,edx; limpio edx
   601 000017A2 F7F3                       div ebx; en eax queda el resultado de la division de eax/ebx y en edx queda el resto!
   602 000017A4 C1EA0C                     shr edx,12; ahora ne edx me queda la posición dentro de la tabla de páginas.
   603 000017A7 B8[00000000]               mov eax, __task2_stack_phy_addr
   604 000017AC 83C803                     or eax,0x03 ;presente y lectoescritura
   605 000017AF 890495[00E00200]           mov [PAGE_TABLE0_TASK2+edx*4],eax;
   606                                     
   607 000017B6 B8[00000000]               mov eax, __task2_stack_NP3_start
   608 000017BB BB00004000                 mov ebx, 0x400000
   609 000017C0 31D2                       xor edx,edx
   610 000017C2 F7F3                       div ebx
   611 000017C4 C1EA0C                     shr edx,12
   612 000017C7 B8[00000000]               mov eax, __task2_stack_NP3_phy_addr
   613 000017CC 83C807                     or eax, 0x07
   614 000017CF 890495[00E00200]           mov [PAGE_TABLE0_TASK2+edx*4],eax
   615                                     
   616 000017D6 B8[00000000]               mov eax, __task2_code_start
   617 000017DB BB00004000                 mov ebx, 0x400000
   618 000017E0 31D2                       xor edx,edx; limpio edx
   619 000017E2 F7F3                       div ebx; en eax queda el resultado de la division de eax/ebx y en edx queda el resto!
   620 000017E4 C1EA0C                     shr edx,12; ahora ne edx me queda la posición dentro de la tabla de páginas.
   621 000017E7 B8[00000000]               mov eax, __task2_code_phy_addr
   622 000017EC 83C807                     or eax,0x07 ; usuario presente y lectoescritura
   623 000017EF 890495[00100300]           mov [PAGE_TABLE6_TASK2+edx*4],eax;
   624                                  
   625                                  ;TAREA 3
   626 000017F6 B8[00000000]               mov eax, __task3_stack_start
   627 000017FB BB00004000                 mov ebx, 0x400000
   628 00001800 31D2                       xor edx,edx; limpio edx
   629 00001802 F7F3                       div ebx; en eax queda el resultado de la division de eax/ebx y en edx queda el resto!
   630 00001804 C1EA0C                     shr edx,12; ahora ne edx me queda la posición dentro de la tabla de páginas.
   631 00001807 B8[00000000]               mov eax, __task3_stack_phy_addr
   632 0000180C 83C803                     or eax,0x03 ;presente y lectoescritura
   633 0000180F 890495[00F00200]           mov [PAGE_TABLE0_TASK3+edx*4],eax;
   634                                     
   635 00001816 B8[00000000]               mov eax, __task3_code_start
   636 0000181B BB00004000                 mov ebx, 0x400000
   637 00001820 31D2                       xor edx,edx; limpio edx
   638 00001822 F7F3                       div ebx; en eax queda el resultado de la division de eax/ebx y en edx queda el resto!
   639 00001824 C1EA0C                     shr edx,12; ahora ne edx me queda la posición dentro de la tabla de páginas.
   640 00001827 B8[00000000]               mov eax, __task3_code_phy_addr
   641 0000182C 83C803                     or eax,0x03 ;presente y lectoescritura
   642 0000182F 890495[00200300]           mov [PAGE_TABLE6_TASK3+edx*4],eax;
   643                                     
   644 00001836 C3                      ret
   645                                  
   646                                  ;--------------------------------------------------------------------------------
   647                                  ;Rutina de copiado de codigo
   648                                  
   649                                  ;void* my_memcpy(void * destination, void* source, uint size);
   650                                  ; EIP de regreso: EBP+4
   651                                  ; destination: EBP+8
   652                                  ; source: EBP+12
   653                                  ; size: EBP+16
   654                                  ;--------------------------------------------------------------------------------
   655                                  my_memcpy:
   656                                    
   657 00001837 55                        push ebp
   658 00001838 89E5                      mov ebp,esp
   659                                    
   660 0000183A 8B750C                    mov esi, [ebp+12]
   661 0000183D 8B7D08                    mov edi, [ebp+8]
   662 00001840 8B4D10                    mov ecx, [ebp+16]
   663 00001843 F3A4                      rep movsb
   664                                    
   665 00001845 5D                        pop ebp
   666                                  
   667 00001846 C3                      ret
   668                                  
   669                                  
   670                                  ;--------------------------------------------------------------------------------
   671                                  ; Inicializacion del controlador de interrupciones
   672                                  ; Corre la base de los tipos de interrupción de ambos PICs 8259A de la PC a los 8 tipos consecutivos a 
   673                                  ; partir de los valores base que recibe en BH para el PIC Nº1 y BL para el PIC Nº2.
   674                                  ; A su retorno las Interrupciones de ambos PICs están deshabilitadas.
   675                                  ;--------------------------------------------------------------------------------
   676                                  InitPIC:
   677                                          ;COMIENZO DE INICIALIZACION: envío la ICW1 a los dos PICs por el puerto de comandos
   678 00001847 B011                            mov al,ICW1_PIC1
   679 00001849 E620                    	out PIC1_COMMAND,al									
   680                                  	
   681 0000184B B011                    	mov al, ICW1_PIC2
   682 0000184D E6A0                    	out PIC2_COMMAND,al
   683                                  	
   684                                  	;MAPEO DE LAS IRQ: la ICW2 va por el port de data no por el de comandos!
   685 0000184F B020                    	mov al,ICW2_PIC1
   686 00001851 E621                    	out PIC1_DATA,al
   687                                  	
   688 00001853 B028                    	mov al,ICW2_PIC2
   689 00001855 E6A1                    	out PIC2_DATA,al
   690                                  	
   691                                  	;SELECCION DE IRQ QUE UNE MAESTRO Y ESCLAVO: envio la ICW3 a los dos PICs, va por data
   692 00001857 B004                            mov al,ICW3_PIC1
   693 00001859 E621                    	out PIC1_DATA,al									
   694                                  	
   695 0000185B B002                    	mov al, ICW3_PIC2
   696 0000185D E6A1                    	out PIC2_DATA,al
   697                                  	
   698                                  	;SETEO MODO x86: envio la ICW4 a los dos PICs, va por data
   699 0000185F B001                    	mov al,ICW4_PIC1
   700 00001861 E621                    	out PIC1_DATA,al									
   701                                  	
   702 00001863 B001                    	mov al, ICW4_PIC2
   703 00001865 E6A1                    	out PIC2_DATA,al
   704                                  	
   705                                  	;En el PIC 1 habilito la IRQ1 (teclado)
   706 00001867 B0FC                    	mov al,MASK_PIC1
   707 00001869 E621                    	out IMR_PIC1, al
   708 0000186B B0FF                    	mov al,MASK_PIC2
   709 0000186D E6A1                    	out IMR_PIC2, al
   710                                  	
   711 0000186F C3                      	ret
   712                                  	
   713                                  ;--------------------------------------------------------------------------------
   714                                  ; Inicializacion del controlador del PIT
   715                                  ;--------------------------------------------------------------------------------
   716                                  InitPIT:
   717                                      
   718 00001870 B036                    	mov al,00110110b
   719 00001872 E643                    	out 0x43, al 
   720                                  	;0x43 Puerto del registro de control del 8253.
   721                                  	;Byte de control 
   722                                  	;  7:6='00', uso el counter/canal 0
   723                                  	;  5:4= '11' esta opcion indica que primero se Lee o carga el LSB y luego el MSB
   724                                          ;  3:1='011' Estos 3 bits indican el modo, en este caso: Modo 3= Square Wave generator. Busco generar una señal cuadrada de 10ms de periodo = 100Hz de frecuencia. El modo 3 hace que la salida este en estado
   725                                          ;0 ='0' Indica que es un contador binario (si estuviera en '1' seria BCD)
   726                                          
   727                                          
   728 00001874 66B8A904                        mov ax, 1193181 / 1000; La frecuencia de clock del contador es 1.193.181Hz / 1000 Hz (que es la frecuencia que quiero) me da las cuentas necesarias para lograr una cuadrada de periodo 1ms
   729                                   
   730                                          ;Ahora debo cargar el canal 0 (0x40) con la cuenta indicada. Para ello, y dado lo especificado en la palabra de control, primero debo cargar el LSB y luego el MSB
   731 00001878 E640                    	out	0x40, al	;LSB
   732 0000187A 86E0                    	xchg	ah, al
   733 0000187C E640                    	out	0x40, al	;MSB
   734                                  
   735 0000187E C3                      ret
   736                                  
   737                                  ;--------------------------------------------------------------------------------
   738                                  ; Inicializacion del controlador de puerto serie
   739                                  ;--------------------------------------------------------------------------------
   740                                  InitCOM1:
   741 0000187F B000                        mov al, 0x00
   742 00001881 66BAF903                    mov dx,COM1+1
   743 00001885 EE                          out dx, al; deshabilito todas las interrupciones
   744                                      
   745 00001886 B080                        mov al, 0x80 
   746 00001888 66BAFB03                    mov dx,COM1+3
   747 0000188C EE                          out dx, al; habilito el bit "DLAB"='1' setear el divisor de baud rate.
   748                                      
   749                                      ;como quiero baud rate=9600bauds => 115200/12 = 9600, ek divisor debe ser 12!
   750                                      ;el LSB del divisor va en COM1+0 y el MSB va en COM1+1, MSB=0x00 y LSB=0x0C
   751 0000188D B00C                        mov al, 0x0C
   752 0000188F 66BAF803                    mov dx, COM1+0
   753 00001893 EE                          out dx,al
   754 00001894 B000                        mov al, 0x00
   755 00001896 66BAF903                    mov dx,COM1+1
   756 0000189A EE                          out dx,al
   757                                      
   758 0000189B B003                        mov al, 00000011b
   759 0000189D 66BAFB03                    mov dx,COM1+3
   760 000018A1 EE                          out dx,al; saco el DLAB='0', break='0', sin paridad = '000', un bit de stop='0', palabra de 8 bits= '11'
   761                                      
   762 000018A2 B000                        mov al, 0x00
   763 000018A4 66BAFA03                    mov dx,COM1+2
   764 000018A8 EE                          out dx, al; DESHABILITO LA PILA!, compatibilidad con 8250
   765                                      
   766 000018A9 B000                        mov al, 0x00; no habilito ninguna
   767 000018AB 66BAF903                    mov dx,COM1+1
   768 000018AF EE                          out dx,al; Habilito las interrupciones de recepcion y de transmision! (0 y 1 respectivamente)
   769                                      
   770 000018B0 C3                      ret
   771                                  
   772                                  
   773                                  ;********************************************************************************
   774                                  ; Tablas de sistema
   775                                  ;********************************************************************************
   776                                  SECTION		.sys_tables 	progbits
   777                                  ALIGN 4
   778                                  
   779                                  ;--------------------------------------------------------------------------------
   780                                  ; GDT
   781                                  ;--------------------------------------------------------------------------------
   782                                  GDT32:
   783                                  
   784                                  SEL_NULO equ $-GDT32
   785 00000000 00<rept>                    times 8 db 0
   786                                      
   787                                  SEL_CODIGO equ $-GDT32
   788 00000008 FF                          db 0xFF; 
   789 00000009 FF                          db 0xFF
   790 0000000A 00                          db 0x00
   791 0000000B 00                          db 0x00
   792 0000000C 00                          db 0x00
   793 0000000D 98                          db 10011000b;
   794 0000000E CF                          db 11001111b;
   795 0000000F 00                          db 0x00
   796                                      
   797                                  SEL_DATOS equ $-GDT32
   798 00000010 FF                          db 0xFF
   799 00000011 FF                          db 0xFF
   800 00000012 00                          db 0x00
   801 00000013 00                          db 0x00
   802 00000014 00                          db 0x00
   803 00000015 92                          db 10010010b;
   804 00000016 CF                          db 11001111b;
   805 00000017 00                          db 0x00
   806                                  
   807                                  SEL_CODIGO_NP3 equ $-GDT32
   808 00000018 FF                          db 0xFF; 
   809 00000019 FF                          db 0xFF
   810 0000001A 00                          db 0x00
   811 0000001B 00                          db 0x00
   812 0000001C 00                          db 0x00
   813 0000001D F8                          db 11111000b;
   814 0000001E CF                          db 11001111b;
   815 0000001F 00                          db 0x00
   816                                  
   817                                  SEL_DATOS_NP3 equ $-GDT32
   818 00000020 FF                          db 0xFF
   819 00000021 FF                          db 0xFF
   820 00000022 00                          db 0x00
   821 00000023 00                          db 0x00
   822 00000024 00                          db 0x00
   823 00000025 F2                          db 11110010b;
   824 00000026 CF                          db 11001111b;
   825 00000027 00                          db 0x00
   826                                  
   827                                  SEL_TSS equ $-GDT32
   828 00000028 6700                        dw LONG_TSS-1
   829 0000002A 0000                        dw 0x00
   830 0000002C 00                          db 0x00
   831 0000002D 89                          db 0x89
   832 0000002E 0000                        dw 0x00
   833                                      
   834                                  LENGTH_GDT equ $-GDT32
   835                                  
   836 00000030 2F00                    my_gdtr: dw LENGTH_GDT-1
   837 00000032 [00000000]                       dd GDT32
   838                                  
   839 00000036 0704                    my_idtr: dw LENGTH_IDT-1
   840 00000038 [00000000]                       dd IDT32
   841                                           
   842                                  ;--------------------------------------------------------------------------------
   843                                  ; IDT
   844                                  ;--------------------------------------------------------------------------------
   845                                  SECTION .sys_idt nobits
   846                                  
   847                                  IDT32:
   848 00000000 <res 00000100>          resq LENGTH_VECT_HANDLERS_EXCEP; Espacio de compuertas para excepciones
   849 00000100 <res 00000080>          resq LENGTH_VECT_HANDLERS_INTERR; Espacio de compuertas para Interrupciones de los PIC 1 y 2
   850 00000180 <res 00000280>          resq LENGTH_HASTA_INT80h; Espacio de compuertas de interrupciones NO UTILIZADAS
   851                                  IDT_INT80h equ $ ; Compuerta de interrupcion 80h para system call.
   852 00000400 <res 00000008>          resq 1
   853                                  LENGTH_IDT equ $-IDT32
   854                                  
   855                                  
   856                                  
   857                                  ;--------------------------------------------------------------------------------
   858                                  ; PILAS DE S.O. Y TAREAS.
   859                                  ;--------------------------------------------------------------------------------
   860                                  SECTION     .stack_so nobits
   861 00000000 <res 00000FFC>          resd STACK_SIZE_SO
   862                                  
   863                                  SECTION     .task1_stack nobits
   864 00000000 <res 00000FFC>          resd STACK_SIZE_TAREAS
   865                                  
   866                                  SECTION     .task2_stack nobits
   867 00000000 <res 00000FFC>          resd STACK_SIZE_TAREAS
   868                                  
   869                                  SECTION     .task3_stack nobits
   870 00000000 <res 00000FFC>          resd STACK_SIZE_TAREAS
   871                                  
   872                                  SECTION     .task1_stack_NP3 nobits
   873 00000000 <res 00000FFC>          resd STACK_SIZE_TAREAS
   874                                  
   875                                  SECTION     .task2_stack_NP3 nobits
   876 00000000 <res 00000FFC>          resd STACK_SIZE_TAREAS
   877                                  
   878                                  ;--------------------------------------------------------------------------------
   879                                  ; TSS
   880                                  ;--------------------------------------------------------------------------------
   881                                  SECTION .tss nobits
   882                                  
   883                                  tss_tt:
   884 00000000 <res 000001A0>              resd LONG_TSS
   885                                      
   886                                  ;--------------------------------------------------------------------------------
   887                                  ; Region de estructuras de contexto de las tareas.
   888                                  ;--------------------------------------------------------------------------------
   889                                  SECTION .contextos nobits
   890                                  ;SS,ESP,EFLAGS,CS y EIP se guardan ya por defecto en la pila de la tarea que se interrumpe!, no hace falta salvarlos
   891                                  ;CR3 tampoco hace falta ya que el scheduler los conoce!
   892                                  ;Se deben salvar: EAX,ECX,EDX,EBX,EBP,ESI,EDI,ES,SS,DS,FS y GS lo que nos da 7 dw y 4w
   893                                  task1_context:
   894 00000000 <res 00000020>              resd 8
   895 00000020 <res 0000000C>              resw 6
   896                                      
   897                                  task2_context:
   898 0000002C <res 00000020>              resd 8
   899 0000004C <res 0000000C>              resw 6
   900                                  
   901                                  task3_context:
   902 00000058 <res 00000020>              resd 8
   903 00000078 <res 0000000C>              resw 6
   904                                  
   905 00000084 90<rept>                ALIGN 16
   906          ******************       warning: attempt to initialize memory in BSS section `.contextos': ignored
   907                                  
   908                                  task1_SIMD:
   909 00000090 <res 00000200>              resb 512
   910                                  task2_SIMD:
   911 00000290 <res 00000200>              resb 512
   912                                  task3_SIMD:
   913 00000490 <res 00000200>              resb 512
   914                                  
   915                                  
   916                                  ;--------------------------------------------------------------------------------
   917                                  ; TABLAS Y DIRECTORIOS DE PAGINAS
   918                                  ;--------------------------------------------------------------------------------
   919                                  SECTION		.pag_tables nobits ; VA NO BITS PARA LOS DATOS NO INICIALIZADOS!!!!
   920                                  PAGE_DIR_SO:
   921 00000000 <res 00001000>              resd 1024
   922                                  
   923                                  PAGE_TABLE0_SO:
   924 00001000 <res 00001000>              resd 1024; defino las 1024 entradas de la tabla de paginas!
   925                                  ;LENGHT_PAGE_TABLE1 equ $-PAGE_TABLE1
   926                                  
   927                                  PAGE_TABLES1_40_SO:
   928 00002000 <res 00027000>              resd 39*1024
   929                                      
   930                                  PAGE_TABLE1023_SO:
   931 00029000 <res 00001000>              resd 1024; defino las 1024 entradas de la tabla de paginas!
   932                                  ;LENGHT_PAGE_TABLE1024 equ $-PAGE_TABLE1024
   933                                  
   934                                  ;DIRECTORIOS Y TABLAS DE PAGINAS CORRESPONDIENTES A LAS TAREAS 
   935                                  PAGE_DIR_TASK1:
   936 0002A000 <res 00001000>              resd 1024
   937                                  PAGE_DIR_TASK2:
   938 0002B000 <res 00001000>              resd 1024
   939                                  PAGE_DIR_TASK3:
   940 0002C000 <res 00001000>              resd 1024
   941                                  
   942                                  PAGE_TABLE0_TASK1:
   943 0002D000 <res 00001000>              resd 1024;
   944                                  PAGE_TABLE0_TASK2:
   945 0002E000 <res 00001000>              resd 1024;
   946                                  PAGE_TABLE0_TASK3:
   947 0002F000 <res 00001000>              resd 1024;
   948                                  
   949                                  PAGE_TABLE6_TASK1:
   950 00030000 <res 00001000>              resd 1024;
   951                                  PAGE_TABLE6_TASK2:
   952 00031000 <res 00001000>              resd 1024;
   953                                  PAGE_TABLE6_TASK3:
   954 00032000 <res 00001000>              resd 1024;
   955                                  
   956                                  ;********************************************************************************
   957                                  ; 						-  -- --- Fin de archivo --- --  -
   958                                  ; D. Garcia 																c2013
   959                                  ;********************************************************************************
   960                                  
